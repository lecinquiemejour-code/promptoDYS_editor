{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useCallback, useRef } from 'react';\nconst DB_NAME = 'EditorStorage';\nconst DB_VERSION = 1;\nconst DOCUMENTS_STORE = 'documents';\n\n/**\n * Hook de stockage de documents avec IndexedDB backend\n * API compatible avec localStorage mais persistant et robuste\n */\nexport const useDocumentStorage = () => {\n  _s();\n  const [isReady, setIsReady] = useState(false);\n  const dbRef = useRef(null);\n  const migrationDoneRef = useRef(false);\n\n  // Initialisation de la base de donn√©es IndexedDB\n  const initDB = useCallback(async () => {\n    if (dbRef.current) return dbRef.current;\n    return new Promise((resolve, reject) => {\n      console.log('üóÑÔ∏è Initialisation IndexedDB pour documents...');\n      const request = indexedDB.open(DB_NAME, DB_VERSION);\n      request.onerror = () => {\n        console.error('‚ùå Erreur ouverture IndexedDB:', request.error);\n        reject(request.error);\n      };\n      request.onsuccess = () => {\n        console.log('‚úÖ IndexedDB initialis√©e avec succ√®s');\n        dbRef.current = request.result;\n        setIsReady(true);\n        resolve(request.result);\n      };\n      request.onupgradeneeded = event => {\n        console.log('üîß Cr√©ation/mise √† jour structure IndexedDB...');\n        const db = event.target.result;\n\n        // Cr√©er l'object store \"documents\" s'il n'existe pas\n        if (!db.objectStoreNames.contains(DOCUMENTS_STORE)) {\n          const store = db.createObjectStore(DOCUMENTS_STORE, {\n            keyPath: 'key'\n          });\n          console.log('üìÅ Object store \"documents\" cr√©√©');\n        }\n      };\n    });\n  }, []);\n\n  // Migration des donn√©es localStorage vers IndexedDB (une seule fois)\n  const migrateFromLocalStorage = useCallback(async db => {\n    if (migrationDoneRef.current) return;\n    console.log('üîÑ Migration localStorage ‚Üí IndexedDB...');\n    const transaction = db.transaction([DOCUMENTS_STORE], 'readwrite');\n    const store = transaction.objectStore(DOCUMENTS_STORE);\n\n    // Lister les cl√©s importantes √† migrer\n    const keysToMigrate = ['editorContent', 'editorViewMode', 'lastSaved'];\n    let migratedCount = 0;\n    for (const key of keysToMigrate) {\n      const localValue = localStorage.getItem(key);\n      if (localValue !== null) {\n        try {\n          await new Promise((resolve, reject) => {\n            const putRequest = store.put({\n              key: key,\n              value: localValue,\n              migratedFrom: 'localStorage',\n              migratedAt: new Date().toISOString()\n            });\n            putRequest.onsuccess = () => resolve();\n            putRequest.onerror = () => reject(putRequest.error);\n          });\n          migratedCount++;\n          console.log(`‚úÖ Migr√©: ${key}`);\n        } catch (error) {\n          console.warn(`‚ö†Ô∏è √âchec migration ${key}:`, error);\n        }\n      }\n    }\n    console.log(`üéâ Migration termin√©e: ${migratedCount} √©l√©ments migr√©s`);\n    migrationDoneRef.current = true;\n    return transaction.complete;\n  }, []);\n\n  // Fonction getItem compatible localStorage\n  const getItem = useCallback(async key => {\n    try {\n      const db = await initDB();\n\n      // Migration automatique au premier acc√®s\n      if (!migrationDoneRef.current) {\n        await migrateFromLocalStorage(db);\n      }\n      return new Promise((resolve, reject) => {\n        const transaction = db.transaction([DOCUMENTS_STORE], 'readonly');\n        const store = transaction.objectStore(DOCUMENTS_STORE);\n        const request = store.get(key);\n        request.onsuccess = () => {\n          const result = request.result;\n          const value = result ? result.value : null;\n          console.log(`üìñ getItem(\"${key}\"):`, value ? `${value.length} chars` : 'null');\n          resolve(value);\n        };\n        request.onerror = () => {\n          console.error(`‚ùå Erreur getItem(\"${key}\"):`, request.error);\n          // Fallback vers localStorage en cas d'erreur\n          const fallbackValue = localStorage.getItem(key);\n          console.log(`üîÑ Fallback localStorage pour \"${key}\":`, fallbackValue ? 'trouv√©' : 'null');\n          resolve(fallbackValue);\n        };\n      });\n    } catch (error) {\n      console.error('‚ùå Erreur IndexedDB getItem, fallback localStorage:', error);\n      return localStorage.getItem(key);\n    }\n  }, [initDB, migrateFromLocalStorage]);\n\n  // Fonction setItem compatible localStorage\n  const setItem = useCallback(async (key, value) => {\n    try {\n      const db = await initDB();\n      return new Promise((resolve, reject) => {\n        const transaction = db.transaction([DOCUMENTS_STORE], 'readwrite');\n        const store = transaction.objectStore(DOCUMENTS_STORE);\n        const data = {\n          key: key,\n          value: value,\n          updatedAt: new Date().toISOString()\n        };\n        const request = store.put(data);\n        request.onsuccess = () => {\n          console.log(`üíæ setItem(\"${key}\"):`, value ? `${value.length} chars sauv√©s` : 'null sauv√©');\n          resolve();\n        };\n        request.onerror = () => {\n          console.error(`‚ùå Erreur setItem(\"${key}\"):`, request.error);\n          // Fallback vers localStorage en cas d'erreur\n          localStorage.setItem(key, value);\n          console.log(`üîÑ Fallback localStorage pour \"${key}\" effectu√©`);\n          resolve();\n        };\n      });\n    } catch (error) {\n      console.error('‚ùå Erreur IndexedDB setItem, fallback localStorage:', error);\n      localStorage.setItem(key, value);\n    }\n  }, [initDB]);\n\n  // Fonction removeItem pour compl√©ter l'API\n  const removeItem = useCallback(async key => {\n    try {\n      const db = await initDB();\n      return new Promise((resolve, reject) => {\n        const transaction = db.transaction([DOCUMENTS_STORE], 'readwrite');\n        const store = transaction.objectStore(DOCUMENTS_STORE);\n        const request = store.delete(key);\n        request.onsuccess = () => {\n          console.log(`üóëÔ∏è removeItem(\"${key}\") effectu√©`);\n          resolve();\n        };\n        request.onerror = () => {\n          console.error(`‚ùå Erreur removeItem(\"${key}\"):`, request.error);\n          localStorage.removeItem(key);\n          resolve();\n        };\n      });\n    } catch (error) {\n      console.error('‚ùå Erreur IndexedDB removeItem, fallback localStorage:', error);\n      localStorage.removeItem(key);\n    }\n  }, [initDB]);\n  return {\n    getItem,\n    setItem,\n    removeItem,\n    isReady\n  };\n};\n_s(useDocumentStorage, \"t6YxYe6sQxsPpIXBHGzJ7VbA8Hk=\");","map":{"version":3,"names":["useState","useCallback","useRef","DB_NAME","DB_VERSION","DOCUMENTS_STORE","useDocumentStorage","_s","isReady","setIsReady","dbRef","migrationDoneRef","initDB","current","Promise","resolve","reject","console","log","request","indexedDB","open","onerror","error","onsuccess","result","onupgradeneeded","event","db","target","objectStoreNames","contains","store","createObjectStore","keyPath","migrateFromLocalStorage","transaction","objectStore","keysToMigrate","migratedCount","key","localValue","localStorage","getItem","putRequest","put","value","migratedFrom","migratedAt","Date","toISOString","warn","complete","get","length","fallbackValue","setItem","data","updatedAt","removeItem","delete"],"sources":["C:/Users/JEAN-NOELLEFEBVRE-SA/CascadeProjects/editor/src/hooks/useDocumentStorage.js"],"sourcesContent":["import { useState, useCallback, useRef } from 'react';\n\nconst DB_NAME = 'EditorStorage';\nconst DB_VERSION = 1;\nconst DOCUMENTS_STORE = 'documents';\n\n/**\n * Hook de stockage de documents avec IndexedDB backend\n * API compatible avec localStorage mais persistant et robuste\n */\nexport const useDocumentStorage = () => {\n  const [isReady, setIsReady] = useState(false);\n  const dbRef = useRef(null);\n  const migrationDoneRef = useRef(false);\n\n  // Initialisation de la base de donn√©es IndexedDB\n  const initDB = useCallback(async () => {\n    if (dbRef.current) return dbRef.current;\n\n    return new Promise((resolve, reject) => {\n      console.log('üóÑÔ∏è Initialisation IndexedDB pour documents...');\n      \n      const request = indexedDB.open(DB_NAME, DB_VERSION);\n      \n      request.onerror = () => {\n        console.error('‚ùå Erreur ouverture IndexedDB:', request.error);\n        reject(request.error);\n      };\n      \n      request.onsuccess = () => {\n        console.log('‚úÖ IndexedDB initialis√©e avec succ√®s');\n        dbRef.current = request.result;\n        setIsReady(true);\n        resolve(request.result);\n      };\n      \n      request.onupgradeneeded = (event) => {\n        console.log('üîß Cr√©ation/mise √† jour structure IndexedDB...');\n        const db = event.target.result;\n        \n        // Cr√©er l'object store \"documents\" s'il n'existe pas\n        if (!db.objectStoreNames.contains(DOCUMENTS_STORE)) {\n          const store = db.createObjectStore(DOCUMENTS_STORE, { keyPath: 'key' });\n          console.log('üìÅ Object store \"documents\" cr√©√©');\n        }\n      };\n    });\n  }, []);\n\n  // Migration des donn√©es localStorage vers IndexedDB (une seule fois)\n  const migrateFromLocalStorage = useCallback(async (db) => {\n    if (migrationDoneRef.current) return;\n    \n    console.log('üîÑ Migration localStorage ‚Üí IndexedDB...');\n    \n    const transaction = db.transaction([DOCUMENTS_STORE], 'readwrite');\n    const store = transaction.objectStore(DOCUMENTS_STORE);\n    \n    // Lister les cl√©s importantes √† migrer\n    const keysToMigrate = [\n      'editorContent',\n      'editorViewMode',\n      'lastSaved'\n    ];\n    \n    let migratedCount = 0;\n    \n    for (const key of keysToMigrate) {\n      const localValue = localStorage.getItem(key);\n      if (localValue !== null) {\n        try {\n          await new Promise((resolve, reject) => {\n            const putRequest = store.put({\n              key: key,\n              value: localValue,\n              migratedFrom: 'localStorage',\n              migratedAt: new Date().toISOString()\n            });\n            putRequest.onsuccess = () => resolve();\n            putRequest.onerror = () => reject(putRequest.error);\n          });\n          migratedCount++;\n          console.log(`‚úÖ Migr√©: ${key}`);\n        } catch (error) {\n          console.warn(`‚ö†Ô∏è √âchec migration ${key}:`, error);\n        }\n      }\n    }\n    \n    console.log(`üéâ Migration termin√©e: ${migratedCount} √©l√©ments migr√©s`);\n    migrationDoneRef.current = true;\n    \n    return transaction.complete;\n  }, []);\n\n  // Fonction getItem compatible localStorage\n  const getItem = useCallback(async (key) => {\n    try {\n      const db = await initDB();\n      \n      // Migration automatique au premier acc√®s\n      if (!migrationDoneRef.current) {\n        await migrateFromLocalStorage(db);\n      }\n      \n      return new Promise((resolve, reject) => {\n        const transaction = db.transaction([DOCUMENTS_STORE], 'readonly');\n        const store = transaction.objectStore(DOCUMENTS_STORE);\n        const request = store.get(key);\n        \n        request.onsuccess = () => {\n          const result = request.result;\n          const value = result ? result.value : null;\n          console.log(`üìñ getItem(\"${key}\"):`, value ? `${value.length} chars` : 'null');\n          resolve(value);\n        };\n        \n        request.onerror = () => {\n          console.error(`‚ùå Erreur getItem(\"${key}\"):`, request.error);\n          // Fallback vers localStorage en cas d'erreur\n          const fallbackValue = localStorage.getItem(key);\n          console.log(`üîÑ Fallback localStorage pour \"${key}\":`, fallbackValue ? 'trouv√©' : 'null');\n          resolve(fallbackValue);\n        };\n      });\n    } catch (error) {\n      console.error('‚ùå Erreur IndexedDB getItem, fallback localStorage:', error);\n      return localStorage.getItem(key);\n    }\n  }, [initDB, migrateFromLocalStorage]);\n\n  // Fonction setItem compatible localStorage\n  const setItem = useCallback(async (key, value) => {\n    try {\n      const db = await initDB();\n      \n      return new Promise((resolve, reject) => {\n        const transaction = db.transaction([DOCUMENTS_STORE], 'readwrite');\n        const store = transaction.objectStore(DOCUMENTS_STORE);\n        \n        const data = {\n          key: key,\n          value: value,\n          updatedAt: new Date().toISOString()\n        };\n        \n        const request = store.put(data);\n        \n        request.onsuccess = () => {\n          console.log(`üíæ setItem(\"${key}\"):`, value ? `${value.length} chars sauv√©s` : 'null sauv√©');\n          resolve();\n        };\n        \n        request.onerror = () => {\n          console.error(`‚ùå Erreur setItem(\"${key}\"):`, request.error);\n          // Fallback vers localStorage en cas d'erreur\n          localStorage.setItem(key, value);\n          console.log(`üîÑ Fallback localStorage pour \"${key}\" effectu√©`);\n          resolve();\n        };\n      });\n    } catch (error) {\n      console.error('‚ùå Erreur IndexedDB setItem, fallback localStorage:', error);\n      localStorage.setItem(key, value);\n    }\n  }, [initDB]);\n\n  // Fonction removeItem pour compl√©ter l'API\n  const removeItem = useCallback(async (key) => {\n    try {\n      const db = await initDB();\n      \n      return new Promise((resolve, reject) => {\n        const transaction = db.transaction([DOCUMENTS_STORE], 'readwrite');\n        const store = transaction.objectStore(DOCUMENTS_STORE);\n        const request = store.delete(key);\n        \n        request.onsuccess = () => {\n          console.log(`üóëÔ∏è removeItem(\"${key}\") effectu√©`);\n          resolve();\n        };\n        \n        request.onerror = () => {\n          console.error(`‚ùå Erreur removeItem(\"${key}\"):`, request.error);\n          localStorage.removeItem(key);\n          resolve();\n        };\n      });\n    } catch (error) {\n      console.error('‚ùå Erreur IndexedDB removeItem, fallback localStorage:', error);\n      localStorage.removeItem(key);\n    }\n  }, [initDB]);\n\n  return {\n    getItem,\n    setItem,\n    removeItem,\n    isReady\n  };\n};\n"],"mappings":";AAAA,SAASA,QAAQ,EAAEC,WAAW,EAAEC,MAAM,QAAQ,OAAO;AAErD,MAAMC,OAAO,GAAG,eAAe;AAC/B,MAAMC,UAAU,GAAG,CAAC;AACpB,MAAMC,eAAe,GAAG,WAAW;;AAEnC;AACA;AACA;AACA;AACA,OAAO,MAAMC,kBAAkB,GAAGA,CAAA,KAAM;EAAAC,EAAA;EACtC,MAAM,CAACC,OAAO,EAAEC,UAAU,CAAC,GAAGT,QAAQ,CAAC,KAAK,CAAC;EAC7C,MAAMU,KAAK,GAAGR,MAAM,CAAC,IAAI,CAAC;EAC1B,MAAMS,gBAAgB,GAAGT,MAAM,CAAC,KAAK,CAAC;;EAEtC;EACA,MAAMU,MAAM,GAAGX,WAAW,CAAC,YAAY;IACrC,IAAIS,KAAK,CAACG,OAAO,EAAE,OAAOH,KAAK,CAACG,OAAO;IAEvC,OAAO,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;MACtCC,OAAO,CAACC,GAAG,CAAC,gDAAgD,CAAC;MAE7D,MAAMC,OAAO,GAAGC,SAAS,CAACC,IAAI,CAAClB,OAAO,EAAEC,UAAU,CAAC;MAEnDe,OAAO,CAACG,OAAO,GAAG,MAAM;QACtBL,OAAO,CAACM,KAAK,CAAC,+BAA+B,EAAEJ,OAAO,CAACI,KAAK,CAAC;QAC7DP,MAAM,CAACG,OAAO,CAACI,KAAK,CAAC;MACvB,CAAC;MAEDJ,OAAO,CAACK,SAAS,GAAG,MAAM;QACxBP,OAAO,CAACC,GAAG,CAAC,qCAAqC,CAAC;QAClDR,KAAK,CAACG,OAAO,GAAGM,OAAO,CAACM,MAAM;QAC9BhB,UAAU,CAAC,IAAI,CAAC;QAChBM,OAAO,CAACI,OAAO,CAACM,MAAM,CAAC;MACzB,CAAC;MAEDN,OAAO,CAACO,eAAe,GAAIC,KAAK,IAAK;QACnCV,OAAO,CAACC,GAAG,CAAC,gDAAgD,CAAC;QAC7D,MAAMU,EAAE,GAAGD,KAAK,CAACE,MAAM,CAACJ,MAAM;;QAE9B;QACA,IAAI,CAACG,EAAE,CAACE,gBAAgB,CAACC,QAAQ,CAAC1B,eAAe,CAAC,EAAE;UAClD,MAAM2B,KAAK,GAAGJ,EAAE,CAACK,iBAAiB,CAAC5B,eAAe,EAAE;YAAE6B,OAAO,EAAE;UAAM,CAAC,CAAC;UACvEjB,OAAO,CAACC,GAAG,CAAC,kCAAkC,CAAC;QACjD;MACF,CAAC;IACH,CAAC,CAAC;EACJ,CAAC,EAAE,EAAE,CAAC;;EAEN;EACA,MAAMiB,uBAAuB,GAAGlC,WAAW,CAAC,MAAO2B,EAAE,IAAK;IACxD,IAAIjB,gBAAgB,CAACE,OAAO,EAAE;IAE9BI,OAAO,CAACC,GAAG,CAAC,0CAA0C,CAAC;IAEvD,MAAMkB,WAAW,GAAGR,EAAE,CAACQ,WAAW,CAAC,CAAC/B,eAAe,CAAC,EAAE,WAAW,CAAC;IAClE,MAAM2B,KAAK,GAAGI,WAAW,CAACC,WAAW,CAAChC,eAAe,CAAC;;IAEtD;IACA,MAAMiC,aAAa,GAAG,CACpB,eAAe,EACf,gBAAgB,EAChB,WAAW,CACZ;IAED,IAAIC,aAAa,GAAG,CAAC;IAErB,KAAK,MAAMC,GAAG,IAAIF,aAAa,EAAE;MAC/B,MAAMG,UAAU,GAAGC,YAAY,CAACC,OAAO,CAACH,GAAG,CAAC;MAC5C,IAAIC,UAAU,KAAK,IAAI,EAAE;QACvB,IAAI;UACF,MAAM,IAAI3B,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;YACrC,MAAM4B,UAAU,GAAGZ,KAAK,CAACa,GAAG,CAAC;cAC3BL,GAAG,EAAEA,GAAG;cACRM,KAAK,EAAEL,UAAU;cACjBM,YAAY,EAAE,cAAc;cAC5BC,UAAU,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC;YACrC,CAAC,CAAC;YACFN,UAAU,CAACpB,SAAS,GAAG,MAAMT,OAAO,CAAC,CAAC;YACtC6B,UAAU,CAACtB,OAAO,GAAG,MAAMN,MAAM,CAAC4B,UAAU,CAACrB,KAAK,CAAC;UACrD,CAAC,CAAC;UACFgB,aAAa,EAAE;UACftB,OAAO,CAACC,GAAG,CAAC,YAAYsB,GAAG,EAAE,CAAC;QAChC,CAAC,CAAC,OAAOjB,KAAK,EAAE;UACdN,OAAO,CAACkC,IAAI,CAAC,sBAAsBX,GAAG,GAAG,EAAEjB,KAAK,CAAC;QACnD;MACF;IACF;IAEAN,OAAO,CAACC,GAAG,CAAC,0BAA0BqB,aAAa,kBAAkB,CAAC;IACtE5B,gBAAgB,CAACE,OAAO,GAAG,IAAI;IAE/B,OAAOuB,WAAW,CAACgB,QAAQ;EAC7B,CAAC,EAAE,EAAE,CAAC;;EAEN;EACA,MAAMT,OAAO,GAAG1C,WAAW,CAAC,MAAOuC,GAAG,IAAK;IACzC,IAAI;MACF,MAAMZ,EAAE,GAAG,MAAMhB,MAAM,CAAC,CAAC;;MAEzB;MACA,IAAI,CAACD,gBAAgB,CAACE,OAAO,EAAE;QAC7B,MAAMsB,uBAAuB,CAACP,EAAE,CAAC;MACnC;MAEA,OAAO,IAAId,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;QACtC,MAAMoB,WAAW,GAAGR,EAAE,CAACQ,WAAW,CAAC,CAAC/B,eAAe,CAAC,EAAE,UAAU,CAAC;QACjE,MAAM2B,KAAK,GAAGI,WAAW,CAACC,WAAW,CAAChC,eAAe,CAAC;QACtD,MAAMc,OAAO,GAAGa,KAAK,CAACqB,GAAG,CAACb,GAAG,CAAC;QAE9BrB,OAAO,CAACK,SAAS,GAAG,MAAM;UACxB,MAAMC,MAAM,GAAGN,OAAO,CAACM,MAAM;UAC7B,MAAMqB,KAAK,GAAGrB,MAAM,GAAGA,MAAM,CAACqB,KAAK,GAAG,IAAI;UAC1C7B,OAAO,CAACC,GAAG,CAAC,eAAesB,GAAG,KAAK,EAAEM,KAAK,GAAG,GAAGA,KAAK,CAACQ,MAAM,QAAQ,GAAG,MAAM,CAAC;UAC9EvC,OAAO,CAAC+B,KAAK,CAAC;QAChB,CAAC;QAED3B,OAAO,CAACG,OAAO,GAAG,MAAM;UACtBL,OAAO,CAACM,KAAK,CAAC,qBAAqBiB,GAAG,KAAK,EAAErB,OAAO,CAACI,KAAK,CAAC;UAC3D;UACA,MAAMgC,aAAa,GAAGb,YAAY,CAACC,OAAO,CAACH,GAAG,CAAC;UAC/CvB,OAAO,CAACC,GAAG,CAAC,kCAAkCsB,GAAG,IAAI,EAAEe,aAAa,GAAG,QAAQ,GAAG,MAAM,CAAC;UACzFxC,OAAO,CAACwC,aAAa,CAAC;QACxB,CAAC;MACH,CAAC,CAAC;IACJ,CAAC,CAAC,OAAOhC,KAAK,EAAE;MACdN,OAAO,CAACM,KAAK,CAAC,oDAAoD,EAAEA,KAAK,CAAC;MAC1E,OAAOmB,YAAY,CAACC,OAAO,CAACH,GAAG,CAAC;IAClC;EACF,CAAC,EAAE,CAAC5B,MAAM,EAAEuB,uBAAuB,CAAC,CAAC;;EAErC;EACA,MAAMqB,OAAO,GAAGvD,WAAW,CAAC,OAAOuC,GAAG,EAAEM,KAAK,KAAK;IAChD,IAAI;MACF,MAAMlB,EAAE,GAAG,MAAMhB,MAAM,CAAC,CAAC;MAEzB,OAAO,IAAIE,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;QACtC,MAAMoB,WAAW,GAAGR,EAAE,CAACQ,WAAW,CAAC,CAAC/B,eAAe,CAAC,EAAE,WAAW,CAAC;QAClE,MAAM2B,KAAK,GAAGI,WAAW,CAACC,WAAW,CAAChC,eAAe,CAAC;QAEtD,MAAMoD,IAAI,GAAG;UACXjB,GAAG,EAAEA,GAAG;UACRM,KAAK,EAAEA,KAAK;UACZY,SAAS,EAAE,IAAIT,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC;QACpC,CAAC;QAED,MAAM/B,OAAO,GAAGa,KAAK,CAACa,GAAG,CAACY,IAAI,CAAC;QAE/BtC,OAAO,CAACK,SAAS,GAAG,MAAM;UACxBP,OAAO,CAACC,GAAG,CAAC,eAAesB,GAAG,KAAK,EAAEM,KAAK,GAAG,GAAGA,KAAK,CAACQ,MAAM,eAAe,GAAG,YAAY,CAAC;UAC3FvC,OAAO,CAAC,CAAC;QACX,CAAC;QAEDI,OAAO,CAACG,OAAO,GAAG,MAAM;UACtBL,OAAO,CAACM,KAAK,CAAC,qBAAqBiB,GAAG,KAAK,EAAErB,OAAO,CAACI,KAAK,CAAC;UAC3D;UACAmB,YAAY,CAACc,OAAO,CAAChB,GAAG,EAAEM,KAAK,CAAC;UAChC7B,OAAO,CAACC,GAAG,CAAC,kCAAkCsB,GAAG,YAAY,CAAC;UAC9DzB,OAAO,CAAC,CAAC;QACX,CAAC;MACH,CAAC,CAAC;IACJ,CAAC,CAAC,OAAOQ,KAAK,EAAE;MACdN,OAAO,CAACM,KAAK,CAAC,oDAAoD,EAAEA,KAAK,CAAC;MAC1EmB,YAAY,CAACc,OAAO,CAAChB,GAAG,EAAEM,KAAK,CAAC;IAClC;EACF,CAAC,EAAE,CAAClC,MAAM,CAAC,CAAC;;EAEZ;EACA,MAAM+C,UAAU,GAAG1D,WAAW,CAAC,MAAOuC,GAAG,IAAK;IAC5C,IAAI;MACF,MAAMZ,EAAE,GAAG,MAAMhB,MAAM,CAAC,CAAC;MAEzB,OAAO,IAAIE,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;QACtC,MAAMoB,WAAW,GAAGR,EAAE,CAACQ,WAAW,CAAC,CAAC/B,eAAe,CAAC,EAAE,WAAW,CAAC;QAClE,MAAM2B,KAAK,GAAGI,WAAW,CAACC,WAAW,CAAChC,eAAe,CAAC;QACtD,MAAMc,OAAO,GAAGa,KAAK,CAAC4B,MAAM,CAACpB,GAAG,CAAC;QAEjCrB,OAAO,CAACK,SAAS,GAAG,MAAM;UACxBP,OAAO,CAACC,GAAG,CAAC,mBAAmBsB,GAAG,aAAa,CAAC;UAChDzB,OAAO,CAAC,CAAC;QACX,CAAC;QAEDI,OAAO,CAACG,OAAO,GAAG,MAAM;UACtBL,OAAO,CAACM,KAAK,CAAC,wBAAwBiB,GAAG,KAAK,EAAErB,OAAO,CAACI,KAAK,CAAC;UAC9DmB,YAAY,CAACiB,UAAU,CAACnB,GAAG,CAAC;UAC5BzB,OAAO,CAAC,CAAC;QACX,CAAC;MACH,CAAC,CAAC;IACJ,CAAC,CAAC,OAAOQ,KAAK,EAAE;MACdN,OAAO,CAACM,KAAK,CAAC,uDAAuD,EAAEA,KAAK,CAAC;MAC7EmB,YAAY,CAACiB,UAAU,CAACnB,GAAG,CAAC;IAC9B;EACF,CAAC,EAAE,CAAC5B,MAAM,CAAC,CAAC;EAEZ,OAAO;IACL+B,OAAO;IACPa,OAAO;IACPG,UAAU;IACVnD;EACF,CAAC;AACH,CAAC;AAACD,EAAA,CA9LWD,kBAAkB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}