{"ast":null,"code":"/**\n * D√©tecteur de format d'image bas√© sur les signatures de fichiers (magic bytes)\n * Analyse les premiers bytes d'un blob pour d√©terminer le vrai format d'image\n */\n\n/**\n * D√©tecte le format d'une image depuis sa signature binaire\n * @param {Blob} blob - Le blob de l'image √† analyser\n * @returns {Promise<string>} - L'extension du fichier (jpg, png, gif, webp, bmp)\n */\nexport const detectImageFormatFromBlob = async blob => {\n  if (!blob || blob.size === 0) {\n    console.warn('‚ö†Ô∏è Blob vide, fallback sur jpg');\n    return 'jpg';\n  }\n  try {\n    // Lire les 12 premiers bytes (suffisant pour toutes les signatures)\n    const buffer = await blob.slice(0, 12).arrayBuffer();\n    const bytes = new Uint8Array(buffer);\n    console.log('üîç Signature d√©tect√©e:', Array.from(bytes.slice(0, 8)).map(b => b.toString(16).padStart(2, '0')).join(' '));\n\n    // JPEG: FF D8 FF\n    if (bytes[0] === 0xFF && bytes[1] === 0xD8 && bytes[2] === 0xFF) {\n      console.log('‚úÖ Format d√©tect√©: JPEG');\n      return 'jpg';\n    }\n\n    // PNG: 89 50 4E 47 0D 0A 1A 0A\n    if (bytes[0] === 0x89 && bytes[1] === 0x50 && bytes[2] === 0x4E && bytes[3] === 0x47) {\n      console.log('‚úÖ Format d√©tect√©: PNG');\n      return 'png';\n    }\n\n    // GIF: 47 49 46 38 (GIF8)\n    if (bytes[0] === 0x47 && bytes[1] === 0x49 && bytes[2] === 0x46 && bytes[3] === 0x38) {\n      console.log('‚úÖ Format d√©tect√©: GIF');\n      return 'gif';\n    }\n\n    // WebP: 52 49 46 46 ... 57 45 42 50 (RIFF...WEBP)\n    if (bytes[0] === 0x52 && bytes[1] === 0x49 && bytes[2] === 0x46 && bytes[3] === 0x46 && bytes[8] === 0x57 && bytes[9] === 0x45 && bytes[10] === 0x42 && bytes[11] === 0x50) {\n      console.log('‚úÖ Format d√©tect√©: WebP');\n      return 'webp';\n    }\n\n    // BMP: 42 4D (BM)\n    if (bytes[0] === 0x42 && bytes[1] === 0x4D) {\n      console.log('‚úÖ Format d√©tect√©: BMP');\n      return 'bmp';\n    }\n\n    // TIFF: 49 49 2A 00 (II*.) ou 4D 4D 00 2A (MM.*)\n    if (bytes[0] === 0x49 && bytes[1] === 0x49 && bytes[2] === 0x2A && bytes[3] === 0x00 || bytes[0] === 0x4D && bytes[1] === 0x4D && bytes[2] === 0x00 && bytes[3] === 0x2A) {\n      console.log('‚úÖ Format d√©tect√©: TIFF');\n      return 'tiff';\n    }\n\n    // ICO: 00 00 01 00\n    if (bytes[0] === 0x00 && bytes[1] === 0x00 && bytes[2] === 0x01 && bytes[3] === 0x00) {\n      console.log('‚úÖ Format d√©tect√©: ICO');\n      return 'ico';\n    }\n    console.warn('‚ö†Ô∏è Format d\\'image non reconnu, fallback sur jpg');\n    console.warn('Signature:', Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join(' '));\n    return 'jpg';\n  } catch (error) {\n    console.error('‚ùå Erreur d√©tection format image:', error);\n    return 'jpg'; // Fallback s√©curis√©\n  }\n};\n\n/**\n * Valide si un format d'image est support√©\n * @param {string} extension - L'extension √† valider\n * @returns {boolean} - True si le format est support√©\n */\nexport const isSupportedImageFormat = extension => {\n  const supportedFormats = ['jpg', 'jpeg', 'png', 'gif', 'webp', 'bmp', 'tiff', 'ico'];\n  return supportedFormats.includes(extension.toLowerCase());\n};\n\n/**\n * Normalise une extension d'image\n * @param {string} extension - L'extension √† normaliser\n * @returns {string} - L'extension normalis√©e\n */\nexport const normalizeImageExtension = extension => {\n  const normalized = extension.toLowerCase();\n\n  // Normaliser jpeg -> jpg\n  if (normalized === 'jpeg') {\n    return 'jpg';\n  }\n  return normalized;\n};","map":{"version":3,"names":["detectImageFormatFromBlob","blob","size","console","warn","buffer","slice","arrayBuffer","bytes","Uint8Array","log","Array","from","map","b","toString","padStart","join","error","isSupportedImageFormat","extension","supportedFormats","includes","toLowerCase","normalizeImageExtension","normalized"],"sources":["C:/Users/JEAN-NOELLEFEBVRE-SA/CascadeProjects/editor/src/utils/imageFormatDetector.js"],"sourcesContent":["/**\n * D√©tecteur de format d'image bas√© sur les signatures de fichiers (magic bytes)\n * Analyse les premiers bytes d'un blob pour d√©terminer le vrai format d'image\n */\n\n/**\n * D√©tecte le format d'une image depuis sa signature binaire\n * @param {Blob} blob - Le blob de l'image √† analyser\n * @returns {Promise<string>} - L'extension du fichier (jpg, png, gif, webp, bmp)\n */\nexport const detectImageFormatFromBlob = async (blob) => {\n  if (!blob || blob.size === 0) {\n    console.warn('‚ö†Ô∏è Blob vide, fallback sur jpg');\n    return 'jpg';\n  }\n\n  try {\n    // Lire les 12 premiers bytes (suffisant pour toutes les signatures)\n    const buffer = await blob.slice(0, 12).arrayBuffer();\n    const bytes = new Uint8Array(buffer);\n    \n    console.log('üîç Signature d√©tect√©e:', Array.from(bytes.slice(0, 8)).map(b => b.toString(16).padStart(2, '0')).join(' '));\n    \n    // JPEG: FF D8 FF\n    if (bytes[0] === 0xFF && bytes[1] === 0xD8 && bytes[2] === 0xFF) {\n      console.log('‚úÖ Format d√©tect√©: JPEG');\n      return 'jpg';\n    }\n    \n    // PNG: 89 50 4E 47 0D 0A 1A 0A\n    if (bytes[0] === 0x89 && bytes[1] === 0x50 && bytes[2] === 0x4E && bytes[3] === 0x47) {\n      console.log('‚úÖ Format d√©tect√©: PNG');\n      return 'png';\n    }\n    \n    // GIF: 47 49 46 38 (GIF8)\n    if (bytes[0] === 0x47 && bytes[1] === 0x49 && bytes[2] === 0x46 && bytes[3] === 0x38) {\n      console.log('‚úÖ Format d√©tect√©: GIF');\n      return 'gif';\n    }\n    \n    // WebP: 52 49 46 46 ... 57 45 42 50 (RIFF...WEBP)\n    if (bytes[0] === 0x52 && bytes[1] === 0x49 && bytes[2] === 0x46 && bytes[3] === 0x46 &&\n        bytes[8] === 0x57 && bytes[9] === 0x45 && bytes[10] === 0x42 && bytes[11] === 0x50) {\n      console.log('‚úÖ Format d√©tect√©: WebP');\n      return 'webp';\n    }\n    \n    // BMP: 42 4D (BM)\n    if (bytes[0] === 0x42 && bytes[1] === 0x4D) {\n      console.log('‚úÖ Format d√©tect√©: BMP');\n      return 'bmp';\n    }\n    \n    // TIFF: 49 49 2A 00 (II*.) ou 4D 4D 00 2A (MM.*)\n    if ((bytes[0] === 0x49 && bytes[1] === 0x49 && bytes[2] === 0x2A && bytes[3] === 0x00) ||\n        (bytes[0] === 0x4D && bytes[1] === 0x4D && bytes[2] === 0x00 && bytes[3] === 0x2A)) {\n      console.log('‚úÖ Format d√©tect√©: TIFF');\n      return 'tiff';\n    }\n    \n    // ICO: 00 00 01 00\n    if (bytes[0] === 0x00 && bytes[1] === 0x00 && bytes[2] === 0x01 && bytes[3] === 0x00) {\n      console.log('‚úÖ Format d√©tect√©: ICO');\n      return 'ico';\n    }\n    \n    console.warn('‚ö†Ô∏è Format d\\'image non reconnu, fallback sur jpg');\n    console.warn('Signature:', Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join(' '));\n    return 'jpg';\n    \n  } catch (error) {\n    console.error('‚ùå Erreur d√©tection format image:', error);\n    return 'jpg'; // Fallback s√©curis√©\n  }\n};\n\n/**\n * Valide si un format d'image est support√©\n * @param {string} extension - L'extension √† valider\n * @returns {boolean} - True si le format est support√©\n */\nexport const isSupportedImageFormat = (extension) => {\n  const supportedFormats = ['jpg', 'jpeg', 'png', 'gif', 'webp', 'bmp', 'tiff', 'ico'];\n  return supportedFormats.includes(extension.toLowerCase());\n};\n\n/**\n * Normalise une extension d'image\n * @param {string} extension - L'extension √† normaliser\n * @returns {string} - L'extension normalis√©e\n */\nexport const normalizeImageExtension = (extension) => {\n  const normalized = extension.toLowerCase();\n  \n  // Normaliser jpeg -> jpg\n  if (normalized === 'jpeg') {\n    return 'jpg';\n  }\n  \n  return normalized;\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMA,yBAAyB,GAAG,MAAOC,IAAI,IAAK;EACvD,IAAI,CAACA,IAAI,IAAIA,IAAI,CAACC,IAAI,KAAK,CAAC,EAAE;IAC5BC,OAAO,CAACC,IAAI,CAAC,gCAAgC,CAAC;IAC9C,OAAO,KAAK;EACd;EAEA,IAAI;IACF;IACA,MAAMC,MAAM,GAAG,MAAMJ,IAAI,CAACK,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC,CAACC,WAAW,CAAC,CAAC;IACpD,MAAMC,KAAK,GAAG,IAAIC,UAAU,CAACJ,MAAM,CAAC;IAEpCF,OAAO,CAACO,GAAG,CAAC,wBAAwB,EAAEC,KAAK,CAACC,IAAI,CAACJ,KAAK,CAACF,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAACO,GAAG,CAACC,CAAC,IAAIA,CAAC,CAACC,QAAQ,CAAC,EAAE,CAAC,CAACC,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,CAACC,IAAI,CAAC,GAAG,CAAC,CAAC;;IAExH;IACA,IAAIT,KAAK,CAAC,CAAC,CAAC,KAAK,IAAI,IAAIA,KAAK,CAAC,CAAC,CAAC,KAAK,IAAI,IAAIA,KAAK,CAAC,CAAC,CAAC,KAAK,IAAI,EAAE;MAC/DL,OAAO,CAACO,GAAG,CAAC,wBAAwB,CAAC;MACrC,OAAO,KAAK;IACd;;IAEA;IACA,IAAIF,KAAK,CAAC,CAAC,CAAC,KAAK,IAAI,IAAIA,KAAK,CAAC,CAAC,CAAC,KAAK,IAAI,IAAIA,KAAK,CAAC,CAAC,CAAC,KAAK,IAAI,IAAIA,KAAK,CAAC,CAAC,CAAC,KAAK,IAAI,EAAE;MACpFL,OAAO,CAACO,GAAG,CAAC,uBAAuB,CAAC;MACpC,OAAO,KAAK;IACd;;IAEA;IACA,IAAIF,KAAK,CAAC,CAAC,CAAC,KAAK,IAAI,IAAIA,KAAK,CAAC,CAAC,CAAC,KAAK,IAAI,IAAIA,KAAK,CAAC,CAAC,CAAC,KAAK,IAAI,IAAIA,KAAK,CAAC,CAAC,CAAC,KAAK,IAAI,EAAE;MACpFL,OAAO,CAACO,GAAG,CAAC,uBAAuB,CAAC;MACpC,OAAO,KAAK;IACd;;IAEA;IACA,IAAIF,KAAK,CAAC,CAAC,CAAC,KAAK,IAAI,IAAIA,KAAK,CAAC,CAAC,CAAC,KAAK,IAAI,IAAIA,KAAK,CAAC,CAAC,CAAC,KAAK,IAAI,IAAIA,KAAK,CAAC,CAAC,CAAC,KAAK,IAAI,IAChFA,KAAK,CAAC,CAAC,CAAC,KAAK,IAAI,IAAIA,KAAK,CAAC,CAAC,CAAC,KAAK,IAAI,IAAIA,KAAK,CAAC,EAAE,CAAC,KAAK,IAAI,IAAIA,KAAK,CAAC,EAAE,CAAC,KAAK,IAAI,EAAE;MACtFL,OAAO,CAACO,GAAG,CAAC,wBAAwB,CAAC;MACrC,OAAO,MAAM;IACf;;IAEA;IACA,IAAIF,KAAK,CAAC,CAAC,CAAC,KAAK,IAAI,IAAIA,KAAK,CAAC,CAAC,CAAC,KAAK,IAAI,EAAE;MAC1CL,OAAO,CAACO,GAAG,CAAC,uBAAuB,CAAC;MACpC,OAAO,KAAK;IACd;;IAEA;IACA,IAAKF,KAAK,CAAC,CAAC,CAAC,KAAK,IAAI,IAAIA,KAAK,CAAC,CAAC,CAAC,KAAK,IAAI,IAAIA,KAAK,CAAC,CAAC,CAAC,KAAK,IAAI,IAAIA,KAAK,CAAC,CAAC,CAAC,KAAK,IAAI,IAChFA,KAAK,CAAC,CAAC,CAAC,KAAK,IAAI,IAAIA,KAAK,CAAC,CAAC,CAAC,KAAK,IAAI,IAAIA,KAAK,CAAC,CAAC,CAAC,KAAK,IAAI,IAAIA,KAAK,CAAC,CAAC,CAAC,KAAK,IAAK,EAAE;MACtFL,OAAO,CAACO,GAAG,CAAC,wBAAwB,CAAC;MACrC,OAAO,MAAM;IACf;;IAEA;IACA,IAAIF,KAAK,CAAC,CAAC,CAAC,KAAK,IAAI,IAAIA,KAAK,CAAC,CAAC,CAAC,KAAK,IAAI,IAAIA,KAAK,CAAC,CAAC,CAAC,KAAK,IAAI,IAAIA,KAAK,CAAC,CAAC,CAAC,KAAK,IAAI,EAAE;MACpFL,OAAO,CAACO,GAAG,CAAC,uBAAuB,CAAC;MACpC,OAAO,KAAK;IACd;IAEAP,OAAO,CAACC,IAAI,CAAC,kDAAkD,CAAC;IAChED,OAAO,CAACC,IAAI,CAAC,YAAY,EAAEO,KAAK,CAACC,IAAI,CAACJ,KAAK,CAAC,CAACK,GAAG,CAACC,CAAC,IAAIA,CAAC,CAACC,QAAQ,CAAC,EAAE,CAAC,CAACC,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,CAACC,IAAI,CAAC,GAAG,CAAC,CAAC;IACjG,OAAO,KAAK;EAEd,CAAC,CAAC,OAAOC,KAAK,EAAE;IACdf,OAAO,CAACe,KAAK,CAAC,kCAAkC,EAAEA,KAAK,CAAC;IACxD,OAAO,KAAK,CAAC,CAAC;EAChB;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,sBAAsB,GAAIC,SAAS,IAAK;EACnD,MAAMC,gBAAgB,GAAG,CAAC,KAAK,EAAE,MAAM,EAAE,KAAK,EAAE,KAAK,EAAE,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,KAAK,CAAC;EACpF,OAAOA,gBAAgB,CAACC,QAAQ,CAACF,SAAS,CAACG,WAAW,CAAC,CAAC,CAAC;AAC3D,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,uBAAuB,GAAIJ,SAAS,IAAK;EACpD,MAAMK,UAAU,GAAGL,SAAS,CAACG,WAAW,CAAC,CAAC;;EAE1C;EACA,IAAIE,UAAU,KAAK,MAAM,EAAE;IACzB,OAAO,KAAK;EACd;EAEA,OAAOA,UAAU;AACnB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}