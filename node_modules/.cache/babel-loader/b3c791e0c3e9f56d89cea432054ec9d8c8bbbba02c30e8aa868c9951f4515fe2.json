{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useCallback, useEffect } from 'react';\nconst DB_NAME = 'EditorImageDB';\nconst DB_VERSION = 1;\nconst STORE_NAME = 'images';\n\n// Maps globales partagÃ©es entre toutes les instances du hook\nconst globalBlobToImageIdMap = new Map();\nconst globalImageIdToBlobMap = new Map(); // Cache pour Ã©viter rechargements\nconst globalImageMetadataCache = new Map(); // Cache des mÃ©tadonnÃ©es complÃ¨tes\nconst pendingImageLoads = new Map(); // Promesses en cours pour Ã©viter les appels parallÃ¨les\n\nexport const useImageStorage = () => {\n  _s();\n  const [db, setDb] = useState(null);\n\n  // ðŸ”„ Vider les caches au dÃ©marrage pour Ã©viter les blob URLs obsolÃ¨tes aprÃ¨s restart\n  useEffect(() => {\n    console.log('ðŸ§¹ Nettoyage des caches blob au dÃ©marrage de useImageStorage');\n    globalImageIdToBlobMap.clear();\n    globalImageMetadataCache.clear();\n    globalBlobToImageIdMap.clear();\n    console.log('âœ… Caches vidÃ©s - nouvelles blob URLs seront crÃ©Ã©es Ã  la demande');\n\n    // DÃ©clencher un Ã©vÃ©nement pour signaler que les caches sont vidÃ©s\n    setTimeout(() => {\n      window.dispatchEvent(new CustomEvent('cacheCleared'));\n      console.log('ðŸ“¡ DEBUG: Ã‰vÃ©nement cacheCleared envoyÃ©');\n    }, 100);\n  }, []);\n\n  // Ouvrir/crÃ©er la base IndexedDB\n  const initDB = useCallback(async () => {\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open(DB_NAME, DB_VERSION);\n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => resolve(request.result);\n      request.onupgradeneeded = event => {\n        const database = event.target.result;\n\n        // CrÃ©er le store si nÃ©cessaire\n        if (!database.objectStoreNames.contains(STORE_NAME)) {\n          const imageStore = database.createObjectStore(STORE_NAME, {\n            keyPath: 'id'\n          });\n          imageStore.createIndex('fileName', 'fileName', {\n            unique: false\n          });\n          imageStore.createIndex('timestamp', 'timestamp', {\n            unique: false\n          });\n        }\n      };\n    });\n  }, []);\n\n  // Stocker une image blob dans IndexedDB\n  const storeImage = useCallback(async (blobUrl, fileName = 'image') => {\n    try {\n      // Initialiser la DB si nÃ©cessaire\n      const database = db || (await initDB());\n      if (!db) setDb(database);\n\n      // RÃ©cupÃ©rer le blob depuis l'URL\n      const response = await fetch(blobUrl);\n      const blob = await response.blob();\n\n      // GÃ©nÃ©rer un ID unique\n      const imageId = `img_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n      // PrÃ©parer les donnÃ©es Ã  stocker\n      const imageData = {\n        id: imageId,\n        fileName: fileName,\n        blob: blob,\n        mimeType: blob.type,\n        size: blob.size,\n        timestamp: new Date().toISOString()\n      };\n\n      // Ã‰crire dans IndexedDB\n      const transaction = database.transaction([STORE_NAME], 'readwrite');\n      const store = transaction.objectStore(STORE_NAME);\n      return new Promise((resolve, reject) => {\n        const request = store.add(imageData);\n        request.onsuccess = () => {\n          // CrÃ©er le mapping blobUrlâ†’imageId pour la sÃ©rialisation\n          globalBlobToImageIdMap.set(blobUrl, imageId);\n          console.log('âœ… Image stockÃ©e dans IndexedDB:', fileName, imageId);\n          console.log('ðŸ”— Mapping crÃ©Ã©:', blobUrl, 'â†’', imageId);\n          console.log('ðŸ”— DIAGNOSTIC storeImage: Nouvelle taille Map:', globalBlobToImageIdMap.size);\n          resolve(imageId);\n        };\n        request.onerror = () => reject(request.error);\n      });\n    } catch (error) {\n      console.error('âŒ Erreur stockage image IndexedDB:', error);\n      throw error;\n    }\n  }, [db, initDB]);\n\n  // Charger une image depuis IndexedDB par son ID\n  const loadImage = useCallback(async imageId => {\n    console.log('ðŸ” DEBUG loadImage: Demande de chargement pour:', imageId);\n    console.log('ðŸ“Š DEBUG: Ã‰tat des caches:', {\n      globalImageIdToBlobMap: globalImageIdToBlobMap.size,\n      globalImageMetadataCache: globalImageMetadataCache.size,\n      hasImageInCache: globalImageIdToBlobMap.has(imageId)\n    });\n\n    // VÃ©rifier le cache d'abord pour Ã©viter rechargements\n    if (globalImageIdToBlobMap.has(imageId) && globalImageMetadataCache.has(imageId)) {\n      const cachedBlobUrl = globalImageIdToBlobMap.get(imageId);\n      const cachedMetadata = globalImageMetadataCache.get(imageId);\n      console.log('ðŸš€ CACHE HIT: Image dÃ©jÃ  en mÃ©moire:', imageId, 'â†’', cachedBlobUrl);\n      return {\n        blobUrl: cachedBlobUrl,\n        fileName: cachedMetadata.fileName,\n        mimeType: cachedMetadata.mimeType,\n        size: cachedMetadata.size\n      };\n    }\n\n    // VÃ©rifier si un chargement est dÃ©jÃ  en cours pour cette image\n    if (pendingImageLoads.has(imageId)) {\n      console.log('â³ CACHE: Chargement dÃ©jÃ  en cours pour:', imageId);\n      return pendingImageLoads.get(imageId);\n    }\n\n    // CrÃ©er une promesse pour ce chargement\n    const loadPromise = (async () => {\n      if (!db) {\n        await initDB();\n      }\n      try {\n        const database = db || (await initDB());\n        if (!db) setDb(database);\n        console.log(' DEBUG: Chargement depuis IndexedDB pour:', imageId);\n        console.log(' DEBUG: Base de donnÃ©es:', database ? 'OK' : 'Non initialisÃ©e');\n        return new Promise((resolve, reject) => {\n          const transaction = database.transaction([STORE_NAME], 'readonly');\n          const store = transaction.objectStore(STORE_NAME);\n          const request = store.get(imageId);\n          request.onsuccess = () => {\n            const result = request.result;\n            console.log(' DEBUG: RÃ©sultat IndexedDB:', {\n              found: !!result,\n              hasBlob: !!(result !== null && result !== void 0 && result.blob),\n              fileName: result === null || result === void 0 ? void 0 : result.fileName,\n              mimeType: result === null || result === void 0 ? void 0 : result.mimeType,\n              size: result === null || result === void 0 ? void 0 : result.size\n            });\n            if (result) {\n              // VÃ©rifier que le blob est valide\n              if (!result.blob || !(result.blob instanceof Blob)) {\n                console.error(' DEBUG: Blob invalide dans IndexedDB');\n                resolve(null);\n                return;\n              }\n              console.log(' DEBUG: Blob valide, type:', result.blob.type, 'taille:', result.blob.size);\n\n              // CrÃ©er une blob URL pour l'affichage\n              let blobUrl;\n              try {\n                blobUrl = URL.createObjectURL(result.blob);\n                console.log(' DEBUG: Blob URL crÃ©Ã©e:', blobUrl);\n              } catch (error) {\n                console.error(' DEBUG: Erreur createObjectURL:', error);\n                resolve(null);\n                return;\n              }\n\n              // Enregistrer les mappings et mÃ©tadonnÃ©es dans le cache\n              globalBlobToImageIdMap.set(blobUrl, imageId);\n              globalImageIdToBlobMap.set(imageId, blobUrl); // Cache pour Ã©viter rechargements\n              globalImageMetadataCache.set(imageId, {\n                fileName: result.fileName,\n                mimeType: result.mimeType,\n                size: result.size\n              });\n              console.log('ðŸ”— DIAGNOSTIC loadImage: Mappings ajoutÃ©s, taille Map:', globalBlobToImageIdMap.size);\n              console.log('ðŸ”— DIAGNOSTIC loadImage: Mapping crÃ©Ã©:', blobUrl, 'â†’', imageId);\n              console.log('ðŸš€ CACHE: Image et mÃ©tadonnÃ©es mises en cache:', imageId, 'â†’', blobUrl);\n              console.log('âœ… Image chargÃ©e depuis IndexedDB:', result.fileName, imageId);\n              resolve({\n                blobUrl,\n                fileName: result.fileName,\n                mimeType: result.mimeType,\n                size: result.size\n              });\n            } else {\n              console.warn('âš ï¸ Image non trouvÃ©e dans IndexedDB:', imageId);\n              resolve(null);\n            }\n          };\n          request.onerror = () => reject(request.error);\n        });\n      } catch (error) {\n        console.error('Erreur lors du chargement de l\\'image:', error);\n        return null;\n      }\n    })();\n\n    // Stocker la promesse en cours\n    pendingImageLoads.set(imageId, loadPromise);\n    try {\n      const result = await loadPromise;\n      return result;\n    } finally {\n      // Nettoyer la promesse une fois terminÃ©e\n      pendingImageLoads.delete(imageId);\n    }\n  }, [db, initDB]);\n\n  // Lister toutes les images stockÃ©es\n  const listImages = useCallback(async () => {\n    try {\n      const database = db || (await initDB());\n      if (!db) setDb(database);\n      const transaction = database.transaction([STORE_NAME], 'readonly');\n      const store = transaction.objectStore(STORE_NAME);\n      return new Promise((resolve, reject) => {\n        const request = store.getAll();\n        request.onsuccess = () => {\n          const images = request.result.map(img => ({\n            id: img.id,\n            fileName: img.fileName,\n            mimeType: img.mimeType,\n            size: img.size,\n            timestamp: img.timestamp\n          }));\n          resolve(images);\n        };\n        request.onerror = () => reject(request.error);\n      });\n    } catch (error) {\n      console.error('âŒ Erreur listage images IndexedDB:', error);\n      return [];\n    }\n  }, [db, initDB]);\n\n  // Supprimer une image\n  const deleteImage = useCallback(async imageId => {\n    try {\n      const database = db || (await initDB());\n      if (!db) setDb(database);\n      const transaction = database.transaction([STORE_NAME], 'readwrite');\n      const store = transaction.objectStore(STORE_NAME);\n      return new Promise((resolve, reject) => {\n        const request = store.delete(imageId);\n        request.onsuccess = () => {\n          console.log('âœ… Image supprimÃ©e de IndexedDB:', imageId);\n          resolve(true);\n        };\n        request.onerror = () => reject(request.error);\n      });\n    } catch (error) {\n      console.error('âŒ Erreur suppression image IndexedDB:', error);\n      return false;\n    }\n  }, [db, initDB]);\n\n  // Convertir les blob URLs vers indexed:// URLs pour sauvegarde\n  const convertBlobUrlsToIndexed = useCallback(htmlContent => {\n    let convertedHtml = htmlContent;\n    let conversionCount = 0;\n\n    // Parcourir toutes les blob URLs dans le mapping\n    globalBlobToImageIdMap.forEach((imageId, blobUrl) => {\n      // Chercher et remplacer cette blob URL par indexed://imageId\n      const blobRegex = new RegExp(blobUrl.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'), 'g');\n      const matches = convertedHtml.match(blobRegex);\n      if (matches) {\n        convertedHtml = convertedHtml.replace(blobRegex, `indexed://${imageId}`);\n        conversionCount += matches.length;\n      }\n    });\n    if (conversionCount > 0) {\n      console.log(`ðŸ”„ ${conversionCount} blob URL(s) converties vers indexed:// pour sauvegarde`);\n    }\n    return convertedHtml;\n  }, []);\n\n  // Nettoyer les images orphelines (non rÃ©fÃ©rencÃ©es dans le contenu)\n  const cleanupOrphanImages = useCallback(async htmlContent => {\n    try {\n      const allImages = await listImages();\n      const usedImageIds = [];\n\n      // Extraire tous les IDs d'images rÃ©fÃ©rencÃ©es dans le HTML\n      const indexedImageRegex = /indexed:\\/\\/(img_[^\"'\\s]+)/g;\n      let match;\n      while ((match = indexedImageRegex.exec(htmlContent)) !== null) {\n        usedImageIds.push(match[1]);\n      }\n\n      // Supprimer les images non rÃ©fÃ©rencÃ©es\n      let deletedCount = 0;\n      for (const image of allImages) {\n        if (!usedImageIds.includes(image.id)) {\n          await deleteImage(image.id);\n          deletedCount++;\n        }\n      }\n      if (deletedCount > 0) {\n        console.log(`ðŸ§¹ ${deletedCount} image(s) orpheline(s) supprimÃ©e(s)`);\n      }\n      return deletedCount;\n    } catch (error) {\n      console.error('âŒ Erreur nettoyage images IndexedDB:', error);\n      return 0;\n    }\n  }, [listImages, deleteImage]);\n\n  // Fonction pour rÃ©cupÃ©rer toutes les correspondances blobâ†’imageId\n  const getAllBlobMappings = useCallback(() => {\n    console.log('ðŸ”Ž DIAGNOSTIC getAllBlobMappings: Map actuelle:', globalBlobToImageIdMap);\n    console.log('ðŸ”Ž DIAGNOSTIC getAllBlobMappings: Taille de la Map:', globalBlobToImageIdMap.size);\n    for (const [blobUrl, imageId] of globalBlobToImageIdMap.entries()) {\n      console.log('ðŸ”— DIAGNOSTIC Mapping:', blobUrl, 'â†’', imageId);\n    }\n    return globalBlobToImageIdMap;\n  }, []);\n  return {\n    storeImage,\n    loadImage,\n    listImages,\n    deleteImage,\n    cleanupOrphanImages,\n    getAllBlobMappings,\n    convertBlobUrlsToIndexed\n  };\n};\n_s(useImageStorage, \"EstjOUbiCZEohWCn0wTerZ39ZcQ=\");","map":{"version":3,"names":["useState","useCallback","useEffect","DB_NAME","DB_VERSION","STORE_NAME","globalBlobToImageIdMap","Map","globalImageIdToBlobMap","globalImageMetadataCache","pendingImageLoads","useImageStorage","_s","db","setDb","console","log","clear","setTimeout","window","dispatchEvent","CustomEvent","initDB","Promise","resolve","reject","request","indexedDB","open","onerror","error","onsuccess","result","onupgradeneeded","event","database","target","objectStoreNames","contains","imageStore","createObjectStore","keyPath","createIndex","unique","storeImage","blobUrl","fileName","response","fetch","blob","imageId","Date","now","Math","random","toString","substr","imageData","id","mimeType","type","size","timestamp","toISOString","transaction","store","objectStore","add","set","loadImage","hasImageInCache","has","cachedBlobUrl","get","cachedMetadata","loadPromise","found","hasBlob","Blob","URL","createObjectURL","warn","delete","listImages","getAll","images","map","img","deleteImage","convertBlobUrlsToIndexed","htmlContent","convertedHtml","conversionCount","forEach","blobRegex","RegExp","replace","matches","match","length","cleanupOrphanImages","allImages","usedImageIds","indexedImageRegex","exec","push","deletedCount","image","includes","getAllBlobMappings","entries"],"sources":["C:/Users/JEAN-NOELLEFEBVRE-SA/CascadeProjects/editor/src/hooks/useImageStorage.js"],"sourcesContent":["import { useState, useCallback, useEffect } from 'react';\n\nconst DB_NAME = 'EditorImageDB';\nconst DB_VERSION = 1;\nconst STORE_NAME = 'images';\n\n// Maps globales partagÃ©es entre toutes les instances du hook\nconst globalBlobToImageIdMap = new Map();\nconst globalImageIdToBlobMap = new Map(); // Cache pour Ã©viter rechargements\nconst globalImageMetadataCache = new Map(); // Cache des mÃ©tadonnÃ©es complÃ¨tes\nconst pendingImageLoads = new Map(); // Promesses en cours pour Ã©viter les appels parallÃ¨les\n\nexport const useImageStorage = () => {\n  const [db, setDb] = useState(null);\n\n  // ðŸ”„ Vider les caches au dÃ©marrage pour Ã©viter les blob URLs obsolÃ¨tes aprÃ¨s restart\n  useEffect(() => {\n    console.log('ðŸ§¹ Nettoyage des caches blob au dÃ©marrage de useImageStorage');\n    globalImageIdToBlobMap.clear();\n    globalImageMetadataCache.clear();\n    globalBlobToImageIdMap.clear();\n    console.log('âœ… Caches vidÃ©s - nouvelles blob URLs seront crÃ©Ã©es Ã  la demande');\n    \n    // DÃ©clencher un Ã©vÃ©nement pour signaler que les caches sont vidÃ©s\n    setTimeout(() => {\n      window.dispatchEvent(new CustomEvent('cacheCleared'));\n      console.log('ðŸ“¡ DEBUG: Ã‰vÃ©nement cacheCleared envoyÃ©');\n    }, 100);\n  }, []);\n\n  // Ouvrir/crÃ©er la base IndexedDB\n  const initDB = useCallback(async () => {\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open(DB_NAME, DB_VERSION);\n      \n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => resolve(request.result);\n      \n      request.onupgradeneeded = (event) => {\n        const database = event.target.result;\n        \n        // CrÃ©er le store si nÃ©cessaire\n        if (!database.objectStoreNames.contains(STORE_NAME)) {\n          const imageStore = database.createObjectStore(STORE_NAME, { keyPath: 'id' });\n          imageStore.createIndex('fileName', 'fileName', { unique: false });\n          imageStore.createIndex('timestamp', 'timestamp', { unique: false });\n        }\n      };\n    });\n  }, []);\n\n  // Stocker une image blob dans IndexedDB\n  const storeImage = useCallback(async (blobUrl, fileName = 'image') => {\n    try {\n      // Initialiser la DB si nÃ©cessaire\n      const database = db || await initDB();\n      if (!db) setDb(database);\n\n      // RÃ©cupÃ©rer le blob depuis l'URL\n      const response = await fetch(blobUrl);\n      const blob = await response.blob();\n\n      // GÃ©nÃ©rer un ID unique\n      const imageId = `img_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n      \n      // PrÃ©parer les donnÃ©es Ã  stocker\n      const imageData = {\n        id: imageId,\n        fileName: fileName,\n        blob: blob,\n        mimeType: blob.type,\n        size: blob.size,\n        timestamp: new Date().toISOString()\n      };\n\n      // Ã‰crire dans IndexedDB\n      const transaction = database.transaction([STORE_NAME], 'readwrite');\n      const store = transaction.objectStore(STORE_NAME);\n      \n      return new Promise((resolve, reject) => {\n        const request = store.add(imageData);\n        request.onsuccess = () => {\n          // CrÃ©er le mapping blobUrlâ†’imageId pour la sÃ©rialisation\n          globalBlobToImageIdMap.set(blobUrl, imageId);\n          console.log('âœ… Image stockÃ©e dans IndexedDB:', fileName, imageId);\n          console.log('ðŸ”— Mapping crÃ©Ã©:', blobUrl, 'â†’', imageId);\n          console.log('ðŸ”— DIAGNOSTIC storeImage: Nouvelle taille Map:', globalBlobToImageIdMap.size);\n          resolve(imageId);\n        };\n        request.onerror = () => reject(request.error);\n      });\n\n    } catch (error) {\n      console.error('âŒ Erreur stockage image IndexedDB:', error);\n      throw error;\n    }\n  }, [db, initDB]);\n\n  // Charger une image depuis IndexedDB par son ID\n  const loadImage = useCallback(async (imageId) => {\n    console.log('ðŸ” DEBUG loadImage: Demande de chargement pour:', imageId);\n    console.log('ðŸ“Š DEBUG: Ã‰tat des caches:', {\n      globalImageIdToBlobMap: globalImageIdToBlobMap.size,\n      globalImageMetadataCache: globalImageMetadataCache.size,\n      hasImageInCache: globalImageIdToBlobMap.has(imageId)\n    });\n    \n    // VÃ©rifier le cache d'abord pour Ã©viter rechargements\n    if (globalImageIdToBlobMap.has(imageId) && globalImageMetadataCache.has(imageId)) {\n      const cachedBlobUrl = globalImageIdToBlobMap.get(imageId);\n      const cachedMetadata = globalImageMetadataCache.get(imageId);\n      console.log('ðŸš€ CACHE HIT: Image dÃ©jÃ  en mÃ©moire:', imageId, 'â†’', cachedBlobUrl);\n      return {\n        blobUrl: cachedBlobUrl,\n        fileName: cachedMetadata.fileName,\n        mimeType: cachedMetadata.mimeType,\n        size: cachedMetadata.size\n      };\n    }\n    \n    // VÃ©rifier si un chargement est dÃ©jÃ  en cours pour cette image\n    if (pendingImageLoads.has(imageId)) {\n      console.log('â³ CACHE: Chargement dÃ©jÃ  en cours pour:', imageId);\n      return pendingImageLoads.get(imageId);\n    }\n    \n    // CrÃ©er une promesse pour ce chargement\n    const loadPromise = (async () => {\n      if (!db) {\n        await initDB();\n      }\n      \n      try {\n      const database = db || await initDB();\n      if (!db) setDb(database);\n\n      \n      console.log(' DEBUG: Chargement depuis IndexedDB pour:', imageId);\n      console.log(' DEBUG: Base de donnÃ©es:', database ? 'OK' : 'Non initialisÃ©e');\n      \n      return new Promise((resolve, reject) => {\n        const transaction = database.transaction([STORE_NAME], 'readonly');\n        const store = transaction.objectStore(STORE_NAME);\n        const request = store.get(imageId);\n        \n        request.onsuccess = () => {\n          const result = request.result;\n          console.log(' DEBUG: RÃ©sultat IndexedDB:', {\n            found: !!result,\n            hasBlob: !!result?.blob,\n            fileName: result?.fileName,\n            mimeType: result?.mimeType,\n            size: result?.size\n          });\n          \n          if (result) {\n            // VÃ©rifier que le blob est valide\n            if (!result.blob || !(result.blob instanceof Blob)) {\n              console.error(' DEBUG: Blob invalide dans IndexedDB');\n              resolve(null);\n              return;\n            }\n            \n            console.log(' DEBUG: Blob valide, type:', result.blob.type, 'taille:', result.blob.size);\n            \n            // CrÃ©er une blob URL pour l'affichage\n            let blobUrl;\n            try {\n              blobUrl = URL.createObjectURL(result.blob);\n              console.log(' DEBUG: Blob URL crÃ©Ã©e:', blobUrl);\n            } catch (error) {\n              console.error(' DEBUG: Erreur createObjectURL:', error);\n              resolve(null);\n              return;\n            }\n            \n            // Enregistrer les mappings et mÃ©tadonnÃ©es dans le cache\n            globalBlobToImageIdMap.set(blobUrl, imageId);\n            globalImageIdToBlobMap.set(imageId, blobUrl); // Cache pour Ã©viter rechargements\n            globalImageMetadataCache.set(imageId, {\n              fileName: result.fileName,\n              mimeType: result.mimeType,\n              size: result.size\n            });\n            console.log('ðŸ”— DIAGNOSTIC loadImage: Mappings ajoutÃ©s, taille Map:', globalBlobToImageIdMap.size);\n            console.log('ðŸ”— DIAGNOSTIC loadImage: Mapping crÃ©Ã©:', blobUrl, 'â†’', imageId);\n            console.log('ðŸš€ CACHE: Image et mÃ©tadonnÃ©es mises en cache:', imageId, 'â†’', blobUrl);\n            \n            console.log('âœ… Image chargÃ©e depuis IndexedDB:', result.fileName, imageId);\n            resolve({\n              blobUrl,\n              fileName: result.fileName,\n              mimeType: result.mimeType,\n              size: result.size\n            });\n          } else {\n            console.warn('âš ï¸ Image non trouvÃ©e dans IndexedDB:', imageId);\n            resolve(null);\n          }\n        };\n        \n        request.onerror = () => reject(request.error);\n      });\n\n      } catch (error) {\n        console.error('Erreur lors du chargement de l\\'image:', error);\n        return null;\n      }\n    })();\n    \n    // Stocker la promesse en cours\n    pendingImageLoads.set(imageId, loadPromise);\n    \n    try {\n      const result = await loadPromise;\n      return result;\n    } finally {\n      // Nettoyer la promesse une fois terminÃ©e\n      pendingImageLoads.delete(imageId);\n    }\n  }, [db, initDB]);\n\n  // Lister toutes les images stockÃ©es\n  const listImages = useCallback(async () => {\n    try {\n      const database = db || await initDB();\n      if (!db) setDb(database);\n\n      const transaction = database.transaction([STORE_NAME], 'readonly');\n      const store = transaction.objectStore(STORE_NAME);\n      \n      return new Promise((resolve, reject) => {\n        const request = store.getAll();\n        request.onsuccess = () => {\n          const images = request.result.map(img => ({\n            id: img.id,\n            fileName: img.fileName,\n            mimeType: img.mimeType,\n            size: img.size,\n            timestamp: img.timestamp\n          }));\n          resolve(images);\n        };\n        request.onerror = () => reject(request.error);\n      });\n\n    } catch (error) {\n      console.error('âŒ Erreur listage images IndexedDB:', error);\n      return [];\n    }\n  }, [db, initDB]);\n\n  // Supprimer une image\n  const deleteImage = useCallback(async (imageId) => {\n    try {\n      const database = db || await initDB();\n      if (!db) setDb(database);\n\n      const transaction = database.transaction([STORE_NAME], 'readwrite');\n      const store = transaction.objectStore(STORE_NAME);\n      \n      return new Promise((resolve, reject) => {\n        const request = store.delete(imageId);\n        request.onsuccess = () => {\n          console.log('âœ… Image supprimÃ©e de IndexedDB:', imageId);\n          resolve(true);\n        };\n        request.onerror = () => reject(request.error);\n      });\n\n    } catch (error) {\n      console.error('âŒ Erreur suppression image IndexedDB:', error);\n      return false;\n    }\n  }, [db, initDB]);\n\n  // Convertir les blob URLs vers indexed:// URLs pour sauvegarde\n  const convertBlobUrlsToIndexed = useCallback((htmlContent) => {\n    let convertedHtml = htmlContent;\n    let conversionCount = 0;\n    \n    // Parcourir toutes les blob URLs dans le mapping\n    globalBlobToImageIdMap.forEach((imageId, blobUrl) => {\n      // Chercher et remplacer cette blob URL par indexed://imageId\n      const blobRegex = new RegExp(blobUrl.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'), 'g');\n      const matches = convertedHtml.match(blobRegex);\n      \n      if (matches) {\n        convertedHtml = convertedHtml.replace(blobRegex, `indexed://${imageId}`);\n        conversionCount += matches.length;\n      }\n    });\n    \n    if (conversionCount > 0) {\n      console.log(`ðŸ”„ ${conversionCount} blob URL(s) converties vers indexed:// pour sauvegarde`);\n    }\n    \n    return convertedHtml;\n  }, []);\n\n  // Nettoyer les images orphelines (non rÃ©fÃ©rencÃ©es dans le contenu)\n  const cleanupOrphanImages = useCallback(async (htmlContent) => {\n    try {\n      const allImages = await listImages();\n      const usedImageIds = [];\n      \n      // Extraire tous les IDs d'images rÃ©fÃ©rencÃ©es dans le HTML\n      const indexedImageRegex = /indexed:\\/\\/(img_[^\"'\\s]+)/g;\n      let match;\n      while ((match = indexedImageRegex.exec(htmlContent)) !== null) {\n        usedImageIds.push(match[1]);\n      }\n\n      // Supprimer les images non rÃ©fÃ©rencÃ©es\n      let deletedCount = 0;\n      for (const image of allImages) {\n        if (!usedImageIds.includes(image.id)) {\n          await deleteImage(image.id);\n          deletedCount++;\n        }\n      }\n\n      if (deletedCount > 0) {\n        console.log(`ðŸ§¹ ${deletedCount} image(s) orpheline(s) supprimÃ©e(s)`);\n      }\n\n      return deletedCount;\n\n    } catch (error) {\n      console.error('âŒ Erreur nettoyage images IndexedDB:', error);\n      return 0;\n    }\n  }, [listImages, deleteImage]);\n\n  // Fonction pour rÃ©cupÃ©rer toutes les correspondances blobâ†’imageId\n  const getAllBlobMappings = useCallback(() => {\n    console.log('ðŸ”Ž DIAGNOSTIC getAllBlobMappings: Map actuelle:', globalBlobToImageIdMap);\n    console.log('ðŸ”Ž DIAGNOSTIC getAllBlobMappings: Taille de la Map:', globalBlobToImageIdMap.size);\n    for (const [blobUrl, imageId] of globalBlobToImageIdMap.entries()) {\n      console.log('ðŸ”— DIAGNOSTIC Mapping:', blobUrl, 'â†’', imageId);\n    }\n    return globalBlobToImageIdMap;\n  }, []);\n\n  return {\n    storeImage,\n    loadImage,\n    listImages,\n    deleteImage,\n    cleanupOrphanImages,\n    getAllBlobMappings,\n    convertBlobUrlsToIndexed\n  };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}