{"ast":null,"code":"// Convertisseur HTML ↔ Markdown pour l'éditeur\n\n/**\n * Convertit du HTML en Markdown\n * @param {string} html - Le contenu HTML à convertir\n * @returns {string} - Le contenu Markdown\n */\nexport const htmlToMarkdown = html => {\n  if (!html) return '';\n\n  // Fonction pour normaliser les couleurs RGB vers hex\n  const rgbToHex = rgb => {\n    const match = rgb.match(/rgb\\((\\d+),\\s*(\\d+),\\s*(\\d+)\\)/);\n    if (!match) return rgb;\n    const r = parseInt(match[1]);\n    const g = parseInt(match[2]);\n    const b = parseInt(match[3]);\n    return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`;\n  };\n\n  // Préserver les spans colorés en les marquant temporairement ET normaliser les couleurs\n  const colorSpanMarkers = [];\n  let tempHtml = html.replace(/<span[^>]*style=\"[^\"]*color:[^\"]*\"[^>]*>.*?<\\/span>/gis, match => {\n    // Normaliser rgb() vers hex dans le span\n    const normalizedMatch = match.replace(/color:\\s*rgb\\([^)]+\\)/gi, colorMatch => {\n      const hexColor = rgbToHex(colorMatch.replace('color:', '').trim());\n      return `color: ${hexColor}`;\n    });\n    const marker = `__COLOR_SPAN_${colorSpanMarkers.length}__`;\n    colorSpanMarkers.push(normalizedMatch);\n    return marker;\n  });\n  let markdown = tempHtml\n  // Décoder les entités HTML AVANT tout traitement\n  .replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&quot;/g, '\"').replace(/&#39;/g, \"'\")\n\n  // Nettoyer le HTML d'abord\n  .replace(/\\n\\s*\\n/g, '\\n') // Supprimer les lignes vides multiples\n  .replace(/^\\s+|\\s+$/g, '') // Trim\n\n  // Titres H1-H6\n  .replace(/<h1[^>]*>(.*?)<\\/h1>/gi, '# $1\\n').replace(/<h2[^>]*>(.*?)<\\/h2>/gi, '## $1\\n').replace(/<h3[^>]*>(.*?)<\\/h3>/gi, '### $1\\n').replace(/<h4[^>]*>(.*?)<\\/h4>/gi, '#### $1\\n').replace(/<h5[^>]*>(.*?)<\\/h5>/gi, '##### $1\\n').replace(/<h6[^>]*>(.*?)<\\/h6>/gi, '###### $1\\n')\n\n  // Images - préserver width, height et data-image-id comme attributs HTML\n  .replace(/<img[^>]*src=\"([^\"]*)\"[^>]*alt=\"([^\"]*)\"[^>]*(width=\"[^\"]*\"|height=\"[^\"]*\"|data-image-id=\"[^\"]*\")[^>]*\\/?>/gi, (match, src, alt) => {\n    const widthMatch = match.match(/width=\"([^\"]*)\"/i);\n    const heightMatch = match.match(/height=\"([^\"]*)\"/i);\n    const imageIdMatch = match.match(/data-image-id=\"([^\"]*)\"/i);\n    let result = `![${alt}](${src})`;\n    const attrs = [];\n    if (widthMatch) attrs.push(`width=${widthMatch[1]}`);\n    if (heightMatch) attrs.push(`height=${heightMatch[1]}`);\n    if (imageIdMatch) attrs.push(`id=${imageIdMatch[1]}`);\n    if (attrs.length > 0) {\n      result += `{${attrs.join(' ')}}`;\n    }\n    return result;\n  }).replace(/<img[^>]*alt=\"([^\"]*)\"[^>]*src=\"([^\"]*)\"[^>]*(width=\"[^\"]*\"|height=\"[^\"]*\"|data-image-id=\"[^\"]*\")[^>]*\\/?>/gi, (match, alt, src) => {\n    const widthMatch = match.match(/width=\"([^\"]*)\"/i);\n    const heightMatch = match.match(/height=\"([^\"]*)\"/i);\n    const imageIdMatch = match.match(/data-image-id=\"([^\"]*)\"/i);\n    let result = `![${alt}](${src})`;\n    const attrs = [];\n    if (widthMatch) attrs.push(`width=${widthMatch[1]}`);\n    if (heightMatch) attrs.push(`height=${heightMatch[1]}`);\n    if (imageIdMatch) attrs.push(`id=${imageIdMatch[1]}`);\n    if (attrs.length > 0) {\n      result += `{${attrs.join(' ')}}`;\n    }\n    return result;\n  }).replace(/<img[^>]*src=\"([^\"]*)\"[^>]*(width=\"[^\"]*\"|height=\"[^\"]*\")[^>]*\\/?>/gi, (match, src) => {\n    const widthMatch = match.match(/width=\"([^\"]*)\"/i);\n    const heightMatch = match.match(/height=\"([^\"]*)\"/i);\n    let result = `![](${src})`;\n    if (widthMatch || heightMatch) {\n      result += '{';\n      if (widthMatch) result += `width=${widthMatch[1]}`;\n      if (widthMatch && heightMatch) result += ' ';\n      if (heightMatch) result += `height=${heightMatch[1]}`;\n      result += '}';\n    }\n    return result;\n  })\n  // Images sans dimensions (fallback)\n  .replace(/<img[^>]*src=\"([^\"]*)\"[^>]*alt=\"([^\"]*)\"[^>]*\\/?>/gi, '![$2]($1)').replace(/<img[^>]*alt=\"([^\"]*)\"[^>]*src=\"([^\"]*)\"[^>]*\\/?>/gi, '![$1]($2)').replace(/<img[^>]*src=\"([^\"]*)\"[^>]*\\/?>/gi, '![]($1)')\n\n  // Formatage gras et italique\n  .replace(/<strong[^>]*>(.*?)<\\/strong>/gi, '**$1**').replace(/<b[^>]*>(.*?)<\\/b>/gi, '**$1**').replace(/<em[^>]*>(.*?)<\\/em>/gi, '*$1*').replace(/<i[^>]*>(.*?)<\\/i>/gi, '*$1*')\n\n  // Paragraphes - vrais blocs avec double saut de ligne\n  .replace(/<p[^>]*>(.*?)<\\/p>/gi, (match, content) => {\n    const trimmed = content.trim();\n    return trimmed ? `${trimmed}\\n\\n` : '';\n  })\n\n  // Divs génériques - lignes simples\n  .replace(/<div[^>]*>(.*?)<\\/div>/gi, '$1\\n')\n\n  // Sauts de ligne\n  .replace(/<br\\s*\\/?>/gi, '\\n')\n\n  // Traiter les listes dans l'ordre de priorité : OL alphabétiques -> OL numériques -> UL puces\n\n  // 1. Listes alphabétiques (OL avec style lower-alpha) - DÉTECTION AMÉLIORÉE\n  .replace(/<ol[^>]*(?:style=\"[^\"]*list-style-type:\\s*lower-alpha[^\"]*\"|style=\"[^\"]*lower-alpha[^\"]*\")[^>]*>(.*?)<\\/ol>/gis, (match, content) => {\n    const items = content.match(/<li[^>]*>(.*?)<\\/li>/gis) || [];\n    const startMatch = match.match(/start=\"(\\d+)\"/);\n    const startIndex = startMatch ? parseInt(startMatch[1]) - 1 : 0;\n    return items.map((item, index) => {\n      const text = item.replace(/<li[^>]*>(.*?)<\\/li>/gis, '$1').trim();\n      const letter = String.fromCharCode(97 + startIndex + index);\n      return `${letter}. ${text}`;\n    }).join('\\n') + '\\n';\n  })\n\n  // 2. Listes numérotées (OL sans style lower-alpha) - REGEX RENFORCÉE\n  .replace(/<ol(?![^>]*(?:style=\"[^\"]*list-style-type:\\s*lower-alpha|style=\"[^\"]*lower-alpha))[^>]*>(.*?)<\\/ol>/gis, (match, content) => {\n    const items = content.match(/<li[^>]*>(.*?)<\\/li>/gis) || [];\n    const startMatch = match.match(/start=\"(\\d+)\"/);\n    const startNumber = startMatch ? parseInt(startMatch[1]) : 1;\n    return items.map((item, index) => {\n      const text = item.replace(/<li[^>]*>(.*?)<\\/li>/gis, '$1').trim();\n      return `${startNumber + index}. ${text}`;\n    }).join('\\n') + '\\n';\n  })\n\n  // 3. Listes à puces (UL) - NETTOYAGE DES BALISES INTERNES\n  .replace(/<ul[^>]*>(.*?)<\\/ul>/gis, (match, content) => {\n    const items = content.match(/<li[^>]*>(.*?)<\\/li>/gis) || [];\n    return items.map(item => {\n      const text = item.replace(/<li[^>]*>(.*?)<\\/li>/gis, '$1').replace(/<[^>]+>/g, '') // Supprimer toutes les balises internes\n      .trim();\n      return `- ${text}`;\n    }).join('\\n') + '\\n';\n  })\n\n  // Restaurer les spans colorés\n  .replace(/__COLOR_SPAN_(\\d+)__/g, (match, index) => {\n    return colorSpanMarkers[parseInt(index)] || '';\n  })\n\n  // Supprimer toutes les autres balises HTML SAUF les spans colorés\n  .replace(/<(?!span\\s+style=\"[^\"]*color:|\\/span>)[^>]+>/gi, '')\n\n  // Nettoyer les espaces multiples\n  .replace(/[ \\t]+/g, ' ').replace(/\\n[ \\t]+/g, '\\n')\n\n  // Normaliser les sauts de ligne sans détruire la structure\n  .replace(/\\n{3,}/g, '\\n\\n') // Maximum 2 sauts consécutifs\n  .trim();\n  return markdown;\n};\n\n/**\n * Convertit du Markdown en HTML\n * @param {string} markdown - Le contenu Markdown à convertir\n * @returns {string} - Le contenu HTML\n */\nexport const markdownToHtml = markdown => {\n  if (!markdown) return '';\n\n  // Préserver les spans HTML existants dans le Markdown\n  const spanMarkers = [];\n  let tempMarkdown = markdown.replace(/<span[^>]*style=\"[^\"]*color:[^\"]*\"[^>]*>.*?<\\/span>/gis, match => {\n    const marker = `__SPAN_PRESERVE_${spanMarkers.length}__`;\n    spanMarkers.push(match);\n    return marker;\n  });\n  let html = tempMarkdown\n  // Échapper les caractères HTML spéciaux SAUF pour les spans préservés\n  .replace(/&(?!__SPAN_PRESERVE_)/g, '&amp;').replace(/<(?!__SPAN_PRESERVE_)/g, '&lt;').replace(/>(?!__SPAN_PRESERVE_)/g, '&gt;')\n\n  // Titres H1-H6\n  .replace(/^#{6}\\s+(.+)$/gm, '<h6>$1</h6>').replace(/^#{5}\\s+(.+)$/gm, '<h5>$1</h5>').replace(/^#{4}\\s+(.+)$/gm, '<h4>$1</h4>').replace(/^#{3}\\s+(.+)$/gm, '<h3>$1</h3>').replace(/^#{2}\\s+(.+)$/gm, '<h2>$1</h2>').replace(/^#{1}\\s+(.+)$/gm, '<h1>$1</h1>')\n\n  // Images - traiter AVANT les autres conversions pour éviter les conflits\n  .replace(/!\\[([^\\]]*)\\]\\(([^)]+)\\)\\{([^}]+)\\}/g, (match, alt, src, dimensions) => {\n    let imgTag = `<img src=\"${src}\" alt=\"${alt}\"`;\n\n    // Parser les dimensions width=X height=Y\n    const widthMatch = dimensions.match(/width=([\\w%]+)/);\n    const heightMatch = dimensions.match(/height=([\\w%]+)/);\n    if (widthMatch) {\n      imgTag += ` width=\"${widthMatch[1]}\"`;\n    }\n    if (heightMatch) {\n      imgTag += ` height=\"${heightMatch[1]}\"`;\n    }\n    imgTag += ' style=\"max-width: 100%; height: auto; margin: 0.5em 0;\" />';\n    return imgTag;\n  })\n  // Images sans dimensions (fallback)\n  .replace(/!\\[([^\\]]*)\\]\\(([^)]+)\\)/g, '<img src=\"$2\" alt=\"$1\" style=\"max-width: 100%; height: auto; margin: 0.5em 0;\" />')\n\n  // Formatage gras et italique\n  .replace(/\\*\\*([^*]+)\\*\\*/g, '<strong>$1</strong>').replace(/\\*([^*]+)\\*/g, '<em>$1</em>')\n\n  // TRAITER LES LISTES AVANT LA CONVERSION \\n -> <br>\n\n  // Listes à puces\n  .replace(/^(\\s*)-\\s+(.+)$/gm, '<li data-type=\"bullet\">$2</li>')\n\n  // Listes numérotées - préserver le numéro original\n  .replace(/^(\\s*)(\\d+)\\.\\s+(.+)$/gm, '<li data-type=\"number\" data-number=\"$2\">$3</li>')\n\n  // Listes alphabétiques - préserver la lettre originale\n  .replace(/^(\\s*)([a-z])\\.\\s+(.+)$/gm, '<li data-type=\"letter\" data-letter=\"$2\">$3</li>')\n\n  // Regrouper les éléments de liste consécutifs PAR TYPE HOMOGÈNE\n  .replace(/(<li[^>]*data-type=\"[^\"]*\"[^>]*>.*?<\\/li>\\n?)+/gs, match => {\n    const items = match.match(/<li[^>]*data-type=\"[^\"]*\"[^>]*>.*?<\\/li>/gs) || [];\n    const groups = [];\n    let currentGroup = [];\n    let currentType = null;\n\n    // Séparer par type homogène\n    for (const item of items) {\n      const typeMatch = item.match(/data-type=\"([^\"]*)\"/);\n      const itemType = typeMatch ? typeMatch[1] : null;\n      if (itemType !== currentType) {\n        // Nouveau type détecté - finaliser le groupe précédent\n        if (currentGroup.length > 0) {\n          groups.push({\n            type: currentType,\n            items: currentGroup\n          });\n        }\n        currentGroup = [item];\n        currentType = itemType;\n      } else {\n        // Même type - ajouter au groupe actuel\n        currentGroup.push(item);\n      }\n    }\n\n    // Finaliser le dernier groupe\n    if (currentGroup.length > 0) {\n      groups.push({\n        type: currentType,\n        items: currentGroup\n      });\n    }\n\n    // Convertir chaque groupe en HTML approprié\n    return groups.map(group => {\n      const {\n        type,\n        items\n      } = group;\n      if (type === 'letter') {\n        // Listes alphabétiques\n        const firstLetterMatch = items[0].match(/data-letter=\"([a-z])\"/);\n        const startLetter = firstLetterMatch ? firstLetterMatch[1] : 'a';\n        const startIndex = startLetter.charCodeAt(0) - 97; // a=0, b=1, c=2...\n        const cleanItems = items.map(item => item.replace(/ data-type=\"[^\"]*\"| data-letter=\"[^\"]*\"/g, ''));\n        if (startIndex > 0) {\n          return `<ol style=\"list-style-type: lower-alpha;\" start=\"${startIndex + 1}\">${cleanItems.join('')}</ol>`;\n        } else {\n          return `<ol style=\"list-style-type: lower-alpha;\">${cleanItems.join('')}</ol>`;\n        }\n      } else if (type === 'number') {\n        // Listes numérotées\n        const firstNumberMatch = items[0].match(/data-number=\"(\\d+)\"/);\n        const startNumber = firstNumberMatch ? parseInt(firstNumberMatch[1]) : 1;\n        const cleanItems = items.map(item => item.replace(/ data-type=\"[^\"]*\"| data-number=\"[^\"]*\"/g, ''));\n        if (startNumber > 1) {\n          return `<ol start=\"${startNumber}\">${cleanItems.join('')}</ol>`;\n        } else {\n          return `<ol>${cleanItems.join('')}</ol>`;\n        }\n      } else if (type === 'bullet') {\n        // Listes à puces\n        const cleanItems = items.map(item => item.replace(/ data-type=\"[^\"]*\"/g, ''));\n        return `<ul>${cleanItems.join('')}</ul>`;\n      } else {\n        // Type inconnu - retourner tel quel\n        return items.join('');\n      }\n    }).join('\\n') + '\\n';\n  })\n\n  // Traiter les paragraphes par blocs séparés par double saut AVANT conversion \\n → <br>\n  .split('\\n\\n').map(block => {\n    block = block.trim();\n    if (!block) return '';\n\n    // Si c'est déjà du HTML (titres, listes), le garder tel quel SANS conversion \\n → <br>\n    if (block.match(/^<h[1-6]|<ul|<ol/)) return block;\n\n    // Si le bloc contient des listes, ne pas l'envelopper dans des divs\n    if (block.match(/<ul|<ol/)) return block;\n\n    // Pour les autres blocs, convertir \\n → <br> puis traiter\n    const processedBlock = block.replace(/\\n(?!\\n)(?!$)/g, '<br>');\n    const lines = processedBlock.split('<br>').map(line => line.trim()).filter(line => line);\n    if (lines.length === 1) {\n      // Une seule ligne → <div> (ligne simple)\n      return `<div>${lines[0]}</div>`;\n    } else {\n      // Plusieurs lignes → <div> avec <br> pour préserver les sauts\n      return `<div>${lines.join('<br>')}</div>`;\n    }\n  }).filter(block => block).join('\\n')\n\n  // Restaurer les spans colorés préservés\n  .replace(/__SPAN_PRESERVE_(\\d+)__/g, (match, index) => {\n    return spanMarkers[parseInt(index)] || '';\n  })\n\n  // Nettoyer les <br> et espaces indésirables après les balises de bloc\n  .replace(/(<\\/(?:ul|ol|h[1-6])>)\\s*<br>/g, '$1').replace(/(<\\/(?:ul|ol|h[1-6])>)\\s*\\n/g, '$1')\n\n  // Nettoyer les lignes vides multiples\n  .replace(/\\n{2,}/g, '\\n').replace(/^\\n+|\\n+$/g, '');\n  return html;\n};\n\n/**\n * Détecte si le contenu contient de la syntaxe Markdown\n * @param {string} content - Le contenu à analyser\n * @returns {boolean} - true si c'est du Markdown\n */\nexport const isMarkdownContent = content => {\n  if (!content) return false;\n  const markdownPatterns = [/^#{1,6}\\s+/m,\n  // Titres\n  /\\*\\*[^*]+\\*\\*/,\n  // Gras\n  /\\*[^*]+\\*/,\n  // Italique\n  /^[-*]\\s+/m,\n  // Listes à puces\n  /^\\d+\\.\\s+/m,\n  // Listes numérotées\n  /^[a-z]\\.\\s+/m,\n  // Listes alphabétiques\n  /!\\[.*?\\]\\([^)]+\\)/ // Images\n  ];\n  return markdownPatterns.some(pattern => pattern.test(content));\n};","map":{"version":3,"names":["htmlToMarkdown","html","rgbToHex","rgb","match","r","parseInt","g","b","toString","slice","colorSpanMarkers","tempHtml","replace","normalizedMatch","colorMatch","hexColor","trim","marker","length","push","markdown","src","alt","widthMatch","heightMatch","imageIdMatch","result","attrs","join","content","trimmed","items","startMatch","startIndex","map","item","index","text","letter","String","fromCharCode","startNumber","markdownToHtml","spanMarkers","tempMarkdown","dimensions","imgTag","groups","currentGroup","currentType","typeMatch","itemType","type","group","firstLetterMatch","startLetter","charCodeAt","cleanItems","firstNumberMatch","split","block","processedBlock","lines","line","filter","isMarkdownContent","markdownPatterns","some","pattern","test"],"sources":["C:/Users/JEAN-NOELLEFEBVRE-SA/CascadeProjects/editor/src/utils/markdownConverter.js"],"sourcesContent":["// Convertisseur HTML ↔ Markdown pour l'éditeur\n\n/**\n * Convertit du HTML en Markdown\n * @param {string} html - Le contenu HTML à convertir\n * @returns {string} - Le contenu Markdown\n */\nexport const htmlToMarkdown = (html) => {\n  if (!html) return '';\n  \n  // Fonction pour normaliser les couleurs RGB vers hex\n  const rgbToHex = (rgb) => {\n    const match = rgb.match(/rgb\\((\\d+),\\s*(\\d+),\\s*(\\d+)\\)/);\n    if (!match) return rgb;\n    \n    const r = parseInt(match[1]);\n    const g = parseInt(match[2]);\n    const b = parseInt(match[3]);\n    \n    return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`;\n  };\n\n  // Préserver les spans colorés en les marquant temporairement ET normaliser les couleurs\n  const colorSpanMarkers = [];\n  let tempHtml = html.replace(/<span[^>]*style=\"[^\"]*color:[^\"]*\"[^>]*>.*?<\\/span>/gis, (match) => {\n    // Normaliser rgb() vers hex dans le span\n    const normalizedMatch = match.replace(/color:\\s*rgb\\([^)]+\\)/gi, (colorMatch) => {\n      const hexColor = rgbToHex(colorMatch.replace('color:', '').trim());\n      return `color: ${hexColor}`;\n    });\n    \n    const marker = `__COLOR_SPAN_${colorSpanMarkers.length}__`;\n    colorSpanMarkers.push(normalizedMatch);\n    return marker;\n  });\n  \n  let markdown = tempHtml\n    // Décoder les entités HTML AVANT tout traitement\n    .replace(/&amp;/g, '&')\n    .replace(/&lt;/g, '<')\n    .replace(/&gt;/g, '>')\n    .replace(/&quot;/g, '\"')\n    .replace(/&#39;/g, \"'\")\n  \n    // Nettoyer le HTML d'abord\n    .replace(/\\n\\s*\\n/g, '\\n') // Supprimer les lignes vides multiples\n    .replace(/^\\s+|\\s+$/g, '') // Trim\n    \n    // Titres H1-H6\n    .replace(/<h1[^>]*>(.*?)<\\/h1>/gi, '# $1\\n')\n    .replace(/<h2[^>]*>(.*?)<\\/h2>/gi, '## $1\\n')\n    .replace(/<h3[^>]*>(.*?)<\\/h3>/gi, '### $1\\n')\n    .replace(/<h4[^>]*>(.*?)<\\/h4>/gi, '#### $1\\n')\n    .replace(/<h5[^>]*>(.*?)<\\/h5>/gi, '##### $1\\n')\n    .replace(/<h6[^>]*>(.*?)<\\/h6>/gi, '###### $1\\n')\n    \n    // Images - préserver width, height et data-image-id comme attributs HTML\n    .replace(/<img[^>]*src=\"([^\"]*)\"[^>]*alt=\"([^\"]*)\"[^>]*(width=\"[^\"]*\"|height=\"[^\"]*\"|data-image-id=\"[^\"]*\")[^>]*\\/?>/gi, (match, src, alt) => {\n      const widthMatch = match.match(/width=\"([^\"]*)\"/i);\n      const heightMatch = match.match(/height=\"([^\"]*)\"/i);\n      const imageIdMatch = match.match(/data-image-id=\"([^\"]*)\"/i);\n      let result = `![${alt}](${src})`;\n      \n      const attrs = [];\n      if (widthMatch) attrs.push(`width=${widthMatch[1]}`);\n      if (heightMatch) attrs.push(`height=${heightMatch[1]}`);\n      if (imageIdMatch) attrs.push(`id=${imageIdMatch[1]}`);\n      \n      if (attrs.length > 0) {\n        result += `{${attrs.join(' ')}}`;\n      }\n      return result;\n    })\n    .replace(/<img[^>]*alt=\"([^\"]*)\"[^>]*src=\"([^\"]*)\"[^>]*(width=\"[^\"]*\"|height=\"[^\"]*\"|data-image-id=\"[^\"]*\")[^>]*\\/?>/gi, (match, alt, src) => {\n      const widthMatch = match.match(/width=\"([^\"]*)\"/i);\n      const heightMatch = match.match(/height=\"([^\"]*)\"/i);\n      const imageIdMatch = match.match(/data-image-id=\"([^\"]*)\"/i);\n      let result = `![${alt}](${src})`;\n      \n      const attrs = [];\n      if (widthMatch) attrs.push(`width=${widthMatch[1]}`);\n      if (heightMatch) attrs.push(`height=${heightMatch[1]}`);\n      if (imageIdMatch) attrs.push(`id=${imageIdMatch[1]}`);\n      \n      if (attrs.length > 0) {\n        result += `{${attrs.join(' ')}}`;\n      }\n      return result;\n    })\n    .replace(/<img[^>]*src=\"([^\"]*)\"[^>]*(width=\"[^\"]*\"|height=\"[^\"]*\")[^>]*\\/?>/gi, (match, src) => {\n      const widthMatch = match.match(/width=\"([^\"]*)\"/i);\n      const heightMatch = match.match(/height=\"([^\"]*)\"/i);\n      let result = `![](${src})`;\n      if (widthMatch || heightMatch) {\n        result += '{'\n        if (widthMatch) result += `width=${widthMatch[1]}`;\n        if (widthMatch && heightMatch) result += ' ';\n        if (heightMatch) result += `height=${heightMatch[1]}`;\n        result += '}';\n      }\n      return result;\n    })\n    // Images sans dimensions (fallback)\n    .replace(/<img[^>]*src=\"([^\"]*)\"[^>]*alt=\"([^\"]*)\"[^>]*\\/?>/gi, '![$2]($1)')\n    .replace(/<img[^>]*alt=\"([^\"]*)\"[^>]*src=\"([^\"]*)\"[^>]*\\/?>/gi, '![$1]($2)')\n    .replace(/<img[^>]*src=\"([^\"]*)\"[^>]*\\/?>/gi, '![]($1)')\n    \n    // Formatage gras et italique\n    .replace(/<strong[^>]*>(.*?)<\\/strong>/gi, '**$1**')\n    .replace(/<b[^>]*>(.*?)<\\/b>/gi, '**$1**')\n    .replace(/<em[^>]*>(.*?)<\\/em>/gi, '*$1*')\n    .replace(/<i[^>]*>(.*?)<\\/i>/gi, '*$1*')\n    \n    // Paragraphes - vrais blocs avec double saut de ligne\n    .replace(/<p[^>]*>(.*?)<\\/p>/gi, (match, content) => {\n      const trimmed = content.trim();\n      return trimmed ? `${trimmed}\\n\\n` : '';\n    })\n    \n    // Divs génériques - lignes simples\n    .replace(/<div[^>]*>(.*?)<\\/div>/gi, '$1\\n')\n    \n    // Sauts de ligne\n    .replace(/<br\\s*\\/?>/gi, '\\n')\n    \n    // Traiter les listes dans l'ordre de priorité : OL alphabétiques -> OL numériques -> UL puces\n    \n    // 1. Listes alphabétiques (OL avec style lower-alpha) - DÉTECTION AMÉLIORÉE\n    .replace(/<ol[^>]*(?:style=\"[^\"]*list-style-type:\\s*lower-alpha[^\"]*\"|style=\"[^\"]*lower-alpha[^\"]*\")[^>]*>(.*?)<\\/ol>/gis, (match, content) => {\n      const items = content.match(/<li[^>]*>(.*?)<\\/li>/gis) || [];\n      const startMatch = match.match(/start=\"(\\d+)\"/); \n      const startIndex = startMatch ? parseInt(startMatch[1]) - 1 : 0;\n      \n      return items.map((item, index) => {\n        const text = item.replace(/<li[^>]*>(.*?)<\\/li>/gis, '$1').trim();\n        const letter = String.fromCharCode(97 + startIndex + index);\n        return `${letter}. ${text}`;\n      }).join('\\n') + '\\n';\n    })\n    \n    // 2. Listes numérotées (OL sans style lower-alpha) - REGEX RENFORCÉE\n    .replace(/<ol(?![^>]*(?:style=\"[^\"]*list-style-type:\\s*lower-alpha|style=\"[^\"]*lower-alpha))[^>]*>(.*?)<\\/ol>/gis, (match, content) => {\n      const items = content.match(/<li[^>]*>(.*?)<\\/li>/gis) || [];\n      const startMatch = match.match(/start=\"(\\d+)\"/); \n      const startNumber = startMatch ? parseInt(startMatch[1]) : 1;\n      \n      return items.map((item, index) => {\n        const text = item.replace(/<li[^>]*>(.*?)<\\/li>/gis, '$1').trim();\n        return `${startNumber + index}. ${text}`;\n      }).join('\\n') + '\\n';\n    })\n    \n    // 3. Listes à puces (UL) - NETTOYAGE DES BALISES INTERNES\n    .replace(/<ul[^>]*>(.*?)<\\/ul>/gis, (match, content) => {\n      const items = content.match(/<li[^>]*>(.*?)<\\/li>/gis) || [];\n      return items.map(item => {\n        const text = item.replace(/<li[^>]*>(.*?)<\\/li>/gis, '$1')\n          .replace(/<[^>]+>/g, '') // Supprimer toutes les balises internes\n          .trim();\n        return `- ${text}`;\n      }).join('\\n') + '\\n';\n    })\n    \n    // Restaurer les spans colorés\n    .replace(/__COLOR_SPAN_(\\d+)__/g, (match, index) => {\n      return colorSpanMarkers[parseInt(index)] || '';\n    })\n    \n    // Supprimer toutes les autres balises HTML SAUF les spans colorés\n    .replace(/<(?!span\\s+style=\"[^\"]*color:|\\/span>)[^>]+>/gi, '')\n    \n    // Nettoyer les espaces multiples\n    .replace(/[ \\t]+/g, ' ')\n    .replace(/\\n[ \\t]+/g, '\\n')\n    \n    // Normaliser les sauts de ligne sans détruire la structure\n    .replace(/\\n{3,}/g, '\\n\\n') // Maximum 2 sauts consécutifs\n    \n    .trim();\n\n  return markdown;\n};\n\n/**\n * Convertit du Markdown en HTML\n * @param {string} markdown - Le contenu Markdown à convertir\n * @returns {string} - Le contenu HTML\n */\nexport const markdownToHtml = (markdown) => {\n  if (!markdown) return '';\n  \n  // Préserver les spans HTML existants dans le Markdown\n  const spanMarkers = [];\n  let tempMarkdown = markdown.replace(/<span[^>]*style=\"[^\"]*color:[^\"]*\"[^>]*>.*?<\\/span>/gis, (match) => {\n    const marker = `__SPAN_PRESERVE_${spanMarkers.length}__`;\n    spanMarkers.push(match);\n    return marker;\n  });\n  \n  let html = tempMarkdown\n    // Échapper les caractères HTML spéciaux SAUF pour les spans préservés\n    .replace(/&(?!__SPAN_PRESERVE_)/g, '&amp;')\n    .replace(/<(?!__SPAN_PRESERVE_)/g, '&lt;')\n    .replace(/>(?!__SPAN_PRESERVE_)/g, '&gt;')\n    \n    // Titres H1-H6\n    .replace(/^#{6}\\s+(.+)$/gm, '<h6>$1</h6>')\n    .replace(/^#{5}\\s+(.+)$/gm, '<h5>$1</h5>')\n    .replace(/^#{4}\\s+(.+)$/gm, '<h4>$1</h4>')\n    .replace(/^#{3}\\s+(.+)$/gm, '<h3>$1</h3>')\n    .replace(/^#{2}\\s+(.+)$/gm, '<h2>$1</h2>')\n    .replace(/^#{1}\\s+(.+)$/gm, '<h1>$1</h1>')\n    \n    // Images - traiter AVANT les autres conversions pour éviter les conflits\n    .replace(/!\\[([^\\]]*)\\]\\(([^)]+)\\)\\{([^}]+)\\}/g, (match, alt, src, dimensions) => {\n      let imgTag = `<img src=\"${src}\" alt=\"${alt}\"`;\n      \n      // Parser les dimensions width=X height=Y\n      const widthMatch = dimensions.match(/width=([\\w%]+)/);\n      const heightMatch = dimensions.match(/height=([\\w%]+)/);\n      \n      if (widthMatch) {\n        imgTag += ` width=\"${widthMatch[1]}\"`;\n      }\n      if (heightMatch) {\n        imgTag += ` height=\"${heightMatch[1]}\"`;\n      }\n      \n      imgTag += ' style=\"max-width: 100%; height: auto; margin: 0.5em 0;\" />';\n      return imgTag;\n    })\n    // Images sans dimensions (fallback)\n    .replace(/!\\[([^\\]]*)\\]\\(([^)]+)\\)/g, '<img src=\"$2\" alt=\"$1\" style=\"max-width: 100%; height: auto; margin: 0.5em 0;\" />')\n    \n    // Formatage gras et italique\n    .replace(/\\*\\*([^*]+)\\*\\*/g, '<strong>$1</strong>')\n    .replace(/\\*([^*]+)\\*/g, '<em>$1</em>')\n    \n    // TRAITER LES LISTES AVANT LA CONVERSION \\n -> <br>\n    \n    // Listes à puces\n    .replace(/^(\\s*)-\\s+(.+)$/gm, '<li data-type=\"bullet\">$2</li>')\n    \n    // Listes numérotées - préserver le numéro original\n    .replace(/^(\\s*)(\\d+)\\.\\s+(.+)$/gm, '<li data-type=\"number\" data-number=\"$2\">$3</li>')\n    \n    // Listes alphabétiques - préserver la lettre originale\n    .replace(/^(\\s*)([a-z])\\.\\s+(.+)$/gm, '<li data-type=\"letter\" data-letter=\"$2\">$3</li>')\n    \n    // Regrouper les éléments de liste consécutifs PAR TYPE HOMOGÈNE\n    .replace(/(<li[^>]*data-type=\"[^\"]*\"[^>]*>.*?<\\/li>\\n?)+/gs, (match) => {\n      const items = match.match(/<li[^>]*data-type=\"[^\"]*\"[^>]*>.*?<\\/li>/gs) || [];\n      const groups = [];\n      let currentGroup = [];\n      let currentType = null;\n      \n      // Séparer par type homogène\n      for (const item of items) {\n        const typeMatch = item.match(/data-type=\"([^\"]*)\"/); \n        const itemType = typeMatch ? typeMatch[1] : null;\n        \n        if (itemType !== currentType) {\n          // Nouveau type détecté - finaliser le groupe précédent\n          if (currentGroup.length > 0) {\n            groups.push({ type: currentType, items: currentGroup });\n          }\n          currentGroup = [item];\n          currentType = itemType;\n        } else {\n          // Même type - ajouter au groupe actuel\n          currentGroup.push(item);\n        }\n      }\n      \n      // Finaliser le dernier groupe\n      if (currentGroup.length > 0) {\n        groups.push({ type: currentType, items: currentGroup });\n      }\n      \n      // Convertir chaque groupe en HTML approprié\n      return groups.map(group => {\n        const { type, items } = group;\n        \n        if (type === 'letter') {\n          // Listes alphabétiques\n          const firstLetterMatch = items[0].match(/data-letter=\"([a-z])\"/); \n          const startLetter = firstLetterMatch ? firstLetterMatch[1] : 'a';\n          const startIndex = startLetter.charCodeAt(0) - 97; // a=0, b=1, c=2...\n          const cleanItems = items.map(item => item.replace(/ data-type=\"[^\"]*\"| data-letter=\"[^\"]*\"/g, ''));\n          \n          if (startIndex > 0) {\n            return `<ol style=\"list-style-type: lower-alpha;\" start=\"${startIndex + 1}\">${cleanItems.join('')}</ol>`;\n          } else {\n            return `<ol style=\"list-style-type: lower-alpha;\">${cleanItems.join('')}</ol>`;\n          }\n        } else if (type === 'number') {\n          // Listes numérotées\n          const firstNumberMatch = items[0].match(/data-number=\"(\\d+)\"/); \n          const startNumber = firstNumberMatch ? parseInt(firstNumberMatch[1]) : 1;\n          const cleanItems = items.map(item => item.replace(/ data-type=\"[^\"]*\"| data-number=\"[^\"]*\"/g, ''));\n          \n          if (startNumber > 1) {\n            return `<ol start=\"${startNumber}\">${cleanItems.join('')}</ol>`;\n          } else {\n            return `<ol>${cleanItems.join('')}</ol>`;\n          }\n        } else if (type === 'bullet') {\n          // Listes à puces\n          const cleanItems = items.map(item => item.replace(/ data-type=\"[^\"]*\"/g, ''));\n          return `<ul>${cleanItems.join('')}</ul>`;\n        } else {\n          // Type inconnu - retourner tel quel\n          return items.join('');\n        }\n      }).join('\\n') + '\\n';\n    })\n    \n    // Traiter les paragraphes par blocs séparés par double saut AVANT conversion \\n → <br>\n    .split('\\n\\n')\n    .map(block => {\n      block = block.trim();\n      if (!block) return '';\n      \n      // Si c'est déjà du HTML (titres, listes), le garder tel quel SANS conversion \\n → <br>\n      if (block.match(/^<h[1-6]|<ul|<ol/)) return block;\n      \n      // Si le bloc contient des listes, ne pas l'envelopper dans des divs\n      if (block.match(/<ul|<ol/)) return block;\n      \n      // Pour les autres blocs, convertir \\n → <br> puis traiter\n      const processedBlock = block.replace(/\\n(?!\\n)(?!$)/g, '<br>');\n      const lines = processedBlock.split('<br>').map(line => line.trim()).filter(line => line);\n      \n      if (lines.length === 1) {\n        // Une seule ligne → <div> (ligne simple)\n        return `<div>${lines[0]}</div>`;\n      } else {\n        // Plusieurs lignes → <div> avec <br> pour préserver les sauts\n        return `<div>${lines.join('<br>')}</div>`;\n      }\n    })\n    .filter(block => block)\n    .join('\\n')\n    \n    // Restaurer les spans colorés préservés\n    .replace(/__SPAN_PRESERVE_(\\d+)__/g, (match, index) => {\n      return spanMarkers[parseInt(index)] || '';\n    })\n    \n    // Nettoyer les <br> et espaces indésirables après les balises de bloc\n    .replace(/(<\\/(?:ul|ol|h[1-6])>)\\s*<br>/g, '$1')\n    .replace(/(<\\/(?:ul|ol|h[1-6])>)\\s*\\n/g, '$1')\n    \n    // Nettoyer les lignes vides multiples\n    .replace(/\\n{2,}/g, '\\n')\n    .replace(/^\\n+|\\n+$/g, '');\n\n  return html;\n};\n\n/**\n * Détecte si le contenu contient de la syntaxe Markdown\n * @param {string} content - Le contenu à analyser\n * @returns {boolean} - true si c'est du Markdown\n */\nexport const isMarkdownContent = (content) => {\n  if (!content) return false;\n  \n  const markdownPatterns = [\n    /^#{1,6}\\s+/m,           // Titres\n    /\\*\\*[^*]+\\*\\*/,         // Gras\n    /\\*[^*]+\\*/,             // Italique\n    /^[-*]\\s+/m,             // Listes à puces\n    /^\\d+\\.\\s+/m,            // Listes numérotées\n    /^[a-z]\\.\\s+/m,          // Listes alphabétiques\n    /!\\[.*?\\]\\([^)]+\\)/      // Images\n  ];\n  \n  return markdownPatterns.some(pattern => pattern.test(content));\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}