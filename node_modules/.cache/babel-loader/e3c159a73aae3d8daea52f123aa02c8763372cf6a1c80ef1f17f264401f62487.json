{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useRef, useCallback, useEffect } from 'react';\nimport { htmlToMarkdown, markdownToHtml } from '../utils/markdownConverter';\nexport const useEditor = () => {\n  _s();\n  const [content, setContent] = useState(() => {\n    const savedContent = localStorage.getItem('editor-content');\n    return savedContent || '<p>Bienvenue dans votre éditeur WYSIWYG</p><p>Commencez à écrire votre <strong>document</strong> ici.</p><p>Le contenu est automatiquement sauvegardé.</p>';\n  });\n\n  // Remplacer isWysiwyg par viewMode avec 3 options\n  const [viewMode, setViewMode] = useState(() => {\n    // Force le mode 'wysiwyg' par défaut - toujours démarrer en mode visuel\n    return 'wysiwyg';\n  });\n  const [currentFormat, setCurrentFormat] = useState(() => {\n    // Récupérer la police sauvegardée depuis localStorage\n    const savedFont = localStorage.getItem('editor-font') || 'system-ui, -apple-system, sans-serif';\n    return {\n      bold: false,\n      italic: false,\n      color: '#000000',\n      fontSize: '16px',\n      fontFamily: savedFont,\n      heading: null,\n      list: null\n    };\n  });\n\n  // État pour gérer l'image sélectionnée\n  const [selectedImage, setSelectedImage] = useState(null);\n\n  // Mémoriser le dernier formatage appliqué pour les débuts de ligne\n  const lastAppliedFormatRef = useRef(null);\n  const editorRef = useRef(null);\n  const selectionRef = useRef(null);\n  const ignoreSelectionChangeRef = useRef(false);\n\n  // Sauvegarder la sélection\n  const saveSelection = useCallback(() => {\n    if (window.getSelection && editorRef.current) {\n      const selection = window.getSelection();\n      if (selection.rangeCount > 0) {\n        selectionRef.current = selection.getRangeAt(0).cloneRange();\n      }\n    }\n  }, []);\n\n  // Restaurer la sélection\n  const restoreSelection = useCallback(() => {\n    if (selectionRef.current && editorRef.current) {\n      const selection = window.getSelection();\n      selection.removeAllRanges();\n      selection.addRange(selectionRef.current);\n      editorRef.current.focus();\n    }\n  }, []);\n\n  // Détecter l'état de formatage à la position du curseur\n  const updateCurrentFormat = useCallback(() => {\n    if (!editorRef.current) return;\n    const selection = window.getSelection();\n    if (!selection.rangeCount) return;\n    const range = selection.getRangeAt(0);\n    let element = range.startContainer;\n\n    // Si c'est un nœud texte, prendre le parent\n    if (element.nodeType === Node.TEXT_NODE) {\n      element = element.parentElement;\n    }\n\n    // Si pas d'élément ou curseur en début de ligne, utiliser l'état mémorisé\n    if (!element || element === editorRef.current) {\n      if (lastAppliedFormatRef.current) {\n        setCurrentFormat(lastAppliedFormatRef.current);\n        return;\n      }\n    }\n\n    // Si on vient d'appliquer un formatage Normal, le préserver\n    if (lastAppliedFormatRef.current && lastAppliedFormatRef.current.heading === null && lastAppliedFormatRef.current.bold === false && lastAppliedFormatRef.current.italic === false) {\n      setCurrentFormat(lastAppliedFormatRef.current);\n      return;\n    }\n\n    // Parcourir vers le haut pour trouver les styles\n    let currentElement = element;\n    const newFormat = {\n      bold: false,\n      italic: false,\n      color: '#000000',\n      fontSize: '16px',\n      fontFamily: 'system-ui',\n      heading: null,\n      list: null\n    };\n    while (currentElement && currentElement !== editorRef.current) {\n      var _currentElement$tagNa, _currentElement$style, _currentElement$style2;\n      const computedStyle = window.getComputedStyle(currentElement);\n      const tagName = (_currentElement$tagNa = currentElement.tagName) === null || _currentElement$tagNa === void 0 ? void 0 : _currentElement$tagNa.toLowerCase();\n\n      // Vérifier les balises de formatage\n      if (tagName === 'strong' || tagName === 'b' || computedStyle.fontWeight === 'bold' || parseInt(computedStyle.fontWeight) >= 700) {\n        newFormat.bold = true;\n      }\n      if (tagName === 'em' || tagName === 'i' || computedStyle.fontStyle === 'italic') {\n        newFormat.italic = true;\n      }\n      if (tagName !== null && tagName !== void 0 && tagName.match(/^h[1-6]$/)) {\n        newFormat.heading = tagName;\n      }\n      if (tagName === 'li') {\n        // Trouver le parent ul ou ol\n        let listParent = currentElement.parentElement;\n        while (listParent && !['ul', 'ol'].includes((_listParent$tagName = listParent.tagName) === null || _listParent$tagName === void 0 ? void 0 : _listParent$tagName.toLowerCase())) {\n          var _listParent$tagName;\n          listParent = listParent.parentElement;\n        }\n        if (listParent) {\n          const parentTag = listParent.tagName.toLowerCase();\n          const listStyle = listParent.style.listStyleType;\n          if (parentTag === 'ul') {\n            newFormat.list = listStyle === 'lower-alpha' ? 'letter' : 'bullet';\n          } else if (parentTag === 'ol') {\n            newFormat.list = listStyle === 'lower-alpha' ? 'letter' : 'number';\n          }\n        }\n      }\n      if (tagName === 'ul') {\n        const listStyle = currentElement.style.listStyleType;\n        newFormat.list = listStyle === 'lower-alpha' ? 'letter' : 'bullet';\n      }\n      if (tagName === 'ol') {\n        const listStyle = currentElement.style.listStyleType;\n        newFormat.list = listStyle === 'lower-alpha' ? 'letter' : 'number';\n      }\n\n      // Vérifier les styles inline et computed\n      if ((_currentElement$style = currentElement.style) !== null && _currentElement$style !== void 0 && _currentElement$style.color) {\n        newFormat.color = currentElement.style.color;\n      } else if (computedStyle.color && computedStyle.color !== 'rgb(0, 0, 0)') {\n        newFormat.color = computedStyle.color;\n      }\n      if ((_currentElement$style2 = currentElement.style) !== null && _currentElement$style2 !== void 0 && _currentElement$style2.fontSize) {\n        newFormat.fontSize = currentElement.style.fontSize;\n      }\n      currentElement = currentElement.parentElement;\n    }\n\n    // Convertir rgb en hex si nécessaire\n    if (newFormat.color.startsWith('rgb')) {\n      newFormat.color = rgbToHex(newFormat.color);\n    }\n    setCurrentFormat(newFormat);\n  }, []);\n\n  // Convertir RGB en HEX\n  const rgbToHex = rgb => {\n    const result = rgb.match(/\\d+/g);\n    if (!result || result.length < 3) return '#000000';\n    const r = parseInt(result[0]);\n    const g = parseInt(result[1]);\n    const b = parseInt(result[2]);\n    return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`;\n  };\n\n  // Gérer les changements de contenu\n  const handleInput = useCallback(e => {\n    if (viewMode === 'wysiwyg') {\n      setContent(e.target.innerHTML);\n      // Laisser selectionchange gérer la synchronisation\n    } else {\n      setContent(e.target.value);\n    }\n  }, [viewMode]);\n\n  // Gérer les changements de sélection\n  const handleSelectionChange = useCallback(() => {\n    if (ignoreSelectionChangeRef.current) {\n      console.log('selectionchange IGNORED');\n      return;\n    }\n    if (viewMode === 'wysiwyg' && document.activeElement === editorRef.current) {\n      console.log('selectionchange PROCESSING');\n      updateCurrentFormat();\n      saveSelection();\n    }\n  }, [viewMode, updateCurrentFormat, saveSelection]);\n\n  // Fonction pour changer de vue avec conversion automatique\n  const changeViewMode = useCallback(newMode => {\n    if (newMode === viewMode) return;\n    let newContent = content;\n\n    // Conversions entre les vues\n    if (viewMode === 'wysiwyg' && newMode === 'markdown') {\n      newContent = htmlToMarkdown(content);\n    } else if (viewMode === 'markdown' && newMode === 'wysiwyg') {\n      newContent = markdownToHtml(content);\n    } else if (viewMode === 'html' && newMode === 'markdown') {\n      newContent = htmlToMarkdown(content);\n    } else if (viewMode === 'markdown' && newMode === 'html') {\n      newContent = markdownToHtml(content);\n    }\n    // wysiwyg -> html : nettoyer les data-attributes\n    if (viewMode === 'wysiwyg' && newMode === 'html') {\n      newContent = content.replace(/ data-type=\"[^\"]*\"/g, '').replace(/ data-number=\"[^\"]*\"/g, '').replace(/ data-letter=\"[^\"]*\"/g, '');\n    }\n    // html -> wysiwyg : pas de conversion nécessaire\n\n    setContent(newContent);\n    setViewMode(newMode);\n  }, [viewMode, content]);\n\n  // Écouter les changements de sélection\n  useEffect(() => {\n    document.addEventListener('selectionchange', handleSelectionChange);\n    return () => {\n      document.removeEventListener('selectionchange', handleSelectionChange);\n    };\n  }, [handleSelectionChange]);\n\n  // Sauvegarder la police sélectionnée dans localStorage\n  useEffect(() => {\n    if (currentFormat.fontFamily) {\n      localStorage.setItem('editor-font', currentFormat.fontFamily);\n    }\n  }, [currentFormat.fontFamily]);\n\n  // Fonction pour sauvegarder l'état appliqué\n  const saveAppliedFormat = useCallback(format => {\n    lastAppliedFormatRef.current = {\n      ...format\n    };\n  }, []);\n\n  // Gestionnaire pour sélectionner une image\n  const handleImageClick = useCallback(imageElement => {\n    if (viewMode === 'wysiwyg') {\n      setSelectedImage(imageElement);\n      // Déselectionner le texte pour éviter les conflits\n      window.getSelection().removeAllRanges();\n    }\n  }, [viewMode]);\n\n  // Gestionnaire pour désélectionner l'image si clic ailleurs\n  const handleEditorClick = useCallback(e => {\n    if (viewMode === 'wysiwyg' && selectedImage) {\n      // Si le clic n'est pas sur l'image sélectionnée, la désélectionner\n      if (e.target !== selectedImage && !selectedImage.contains(e.target)) {\n        setSelectedImage(null);\n      }\n    }\n  }, [viewMode, selectedImage]);\n\n  // Gestionnaire complet pour tous les événements clavier des images\n  const handleImageKeyboardEvents = useCallback(e => {\n    var _editorRef$current4;\n    if (viewMode !== 'wysiwyg' || !selectedImage) return;\n    switch (e.key) {\n      case 'Delete':\n      case 'Backspace':\n        e.preventDefault();\n        // Supprimer l'image du DOM (wrapper complet si présent)\n        const wrapper = selectedImage.closest('.resizable-image, .image-block');\n        const elementToRemove = wrapper || selectedImage;\n\n        // Sauvegarder la position pour navigation\n        const nextElement = elementToRemove.nextElementSibling;\n        const prevElement = elementToRemove.previousElementSibling;\n        elementToRemove.remove();\n        setSelectedImage(null);\n\n        // Placer le curseur après suppression\n        setTimeout(() => {\n          var _editorRef$current;\n          if (nextElement) {\n            const range = document.createRange();\n            const selection = window.getSelection();\n            range.setStart(nextElement, 0);\n            range.collapse(true);\n            selection.removeAllRanges();\n            selection.addRange(range);\n          } else if (prevElement) {\n            const range = document.createRange();\n            const selection = window.getSelection();\n            range.setStartAfter(prevElement);\n            range.collapse(true);\n            selection.removeAllRanges();\n            selection.addRange(range);\n          }\n          (_editorRef$current = editorRef.current) === null || _editorRef$current === void 0 ? void 0 : _editorRef$current.focus();\n        }, 10);\n\n        // Déclencher la sauvegarde\n        if (editorRef.current) {\n          const event = new Event('input', {\n            bubbles: true\n          });\n          editorRef.current.dispatchEvent(event);\n        }\n        break;\n      case 'Enter':\n        e.preventDefault();\n        // Créer un nouveau paragraphe après l'image\n        const imageWrapper = selectedImage.closest('.resizable-image, .image-block');\n        const imageContainer = imageWrapper || selectedImage;\n\n        // Créer un nouveau paragraphe\n        const newParagraph = document.createElement('p');\n        newParagraph.innerHTML = '<br>';\n\n        // Insérer après l'image\n        targetElement.parentNode.insertBefore(newParagraph, targetElement.nextSibling);\n\n        // Placer le curseur dans le nouveau paragraphe\n        setTimeout(() => {\n          var _editorRef$current2;\n          const range = document.createRange();\n          const selection = window.getSelection();\n          range.setStart(newParagraph, 0);\n          range.collapse(true);\n          selection.removeAllRanges();\n          selection.addRange(range);\n          (_editorRef$current2 = editorRef.current) === null || _editorRef$current2 === void 0 ? void 0 : _editorRef$current2.focus();\n        }, 10);\n\n        // Désélectionner l'image\n        setSelectedImage(null);\n\n        // Déclencher la sauvegarde\n        if (editorRef.current) {\n          const event = new Event('input', {\n            bubbles: true\n          });\n          editorRef.current.dispatchEvent(event);\n        }\n        break;\n      case 'ArrowUp':\n      case 'ArrowDown':\n        e.preventDefault();\n        // Navigation entre images et éléments\n        const currentWrapper = selectedImage.closest('.resizable-image, .image-block');\n        const currentElement = currentWrapper || selectedImage;\n        let targetElement;\n        if (e.key === 'ArrowUp') {\n          targetElement = currentElement.previousElementSibling;\n        } else {\n          targetElement = currentElement.nextElementSibling;\n        }\n        if (targetElement) {\n          // Si c'est une autre image, la sélectionner\n          const targetImage = targetElement.querySelector('img');\n          if (targetImage) {\n            setSelectedImage(targetImage);\n          } else {\n            // Sinon, placer le curseur dans l'élément\n            setSelectedImage(null);\n            setTimeout(() => {\n              var _editorRef$current3;\n              const range = document.createRange();\n              const selection = window.getSelection();\n              if (e.key === 'ArrowUp') {\n                range.setStart(targetElement, targetElement.childNodes.length);\n              } else {\n                range.setStart(targetElement, 0);\n              }\n              range.collapse(true);\n              selection.removeAllRanges();\n              selection.addRange(range);\n              (_editorRef$current3 = editorRef.current) === null || _editorRef$current3 === void 0 ? void 0 : _editorRef$current3.focus();\n            }, 10);\n          }\n        }\n        break;\n      case 'Escape':\n        e.preventDefault();\n        // Désélectionner l'image\n        setSelectedImage(null);\n        (_editorRef$current4 = editorRef.current) === null || _editorRef$current4 === void 0 ? void 0 : _editorRef$current4.focus();\n        break;\n      default:\n        // Pour les autres touches, ne rien faire\n        break;\n    }\n  }, [viewMode, selectedImage]);\n  return {\n    content,\n    setContent,\n    viewMode,\n    setViewMode,\n    changeViewMode,\n    // Compatibilité avec l'ancien système\n    isWysiwyg: viewMode === 'wysiwyg',\n    setIsWysiwyg: value => changeViewMode(value ? 'wysiwyg' : 'html'),\n    currentFormat,\n    setCurrentFormat,\n    editorRef,\n    handleInput,\n    saveSelection,\n    restoreSelection,\n    updateCurrentFormat,\n    saveAppliedFormat,\n    ignoreSelectionChangeRef,\n    // Gestion de sélection d'images\n    selectedImage,\n    setSelectedImage,\n    handleImageClick,\n    handleEditorClick,\n    handleImageKeyboardEvents\n  };\n};\n_s(useEditor, \"DAm0F324nV5OrWEEYq9lCzfdQtw=\");","map":{"version":3,"names":["useState","useRef","useCallback","useEffect","htmlToMarkdown","markdownToHtml","useEditor","_s","content","setContent","savedContent","localStorage","getItem","viewMode","setViewMode","currentFormat","setCurrentFormat","savedFont","bold","italic","color","fontSize","fontFamily","heading","list","selectedImage","setSelectedImage","lastAppliedFormatRef","editorRef","selectionRef","ignoreSelectionChangeRef","saveSelection","window","getSelection","current","selection","rangeCount","getRangeAt","cloneRange","restoreSelection","removeAllRanges","addRange","focus","updateCurrentFormat","range","element","startContainer","nodeType","Node","TEXT_NODE","parentElement","currentElement","newFormat","_currentElement$tagNa","_currentElement$style","_currentElement$style2","computedStyle","getComputedStyle","tagName","toLowerCase","fontWeight","parseInt","fontStyle","match","listParent","includes","_listParent$tagName","parentTag","listStyle","style","listStyleType","startsWith","rgbToHex","rgb","result","length","r","g","b","toString","slice","handleInput","e","target","innerHTML","value","handleSelectionChange","console","log","document","activeElement","changeViewMode","newMode","newContent","replace","addEventListener","removeEventListener","setItem","saveAppliedFormat","format","handleImageClick","imageElement","handleEditorClick","contains","handleImageKeyboardEvents","_editorRef$current4","key","preventDefault","wrapper","closest","elementToRemove","nextElement","nextElementSibling","prevElement","previousElementSibling","remove","setTimeout","_editorRef$current","createRange","setStart","collapse","setStartAfter","event","Event","bubbles","dispatchEvent","imageWrapper","imageContainer","newParagraph","createElement","targetElement","parentNode","insertBefore","nextSibling","_editorRef$current2","currentWrapper","targetImage","querySelector","_editorRef$current3","childNodes","isWysiwyg","setIsWysiwyg"],"sources":["C:/Users/JEAN-NOELLEFEBVRE-SA/CascadeProjects/editor/src/hooks/useEditor.js"],"sourcesContent":["import { useState, useRef, useCallback, useEffect } from 'react';\nimport { htmlToMarkdown, markdownToHtml } from '../utils/markdownConverter';\n\nexport const useEditor = () => {\n  const [content, setContent] = useState(() => {\n    const savedContent = localStorage.getItem('editor-content');\n    return savedContent || '<p>Bienvenue dans votre éditeur WYSIWYG</p><p>Commencez à écrire votre <strong>document</strong> ici.</p><p>Le contenu est automatiquement sauvegardé.</p>';\n  });\n  \n  // Remplacer isWysiwyg par viewMode avec 3 options\n  const [viewMode, setViewMode] = useState(() => {\n    // Force le mode 'wysiwyg' par défaut - toujours démarrer en mode visuel\n    return 'wysiwyg';\n  });\n  \n  const [currentFormat, setCurrentFormat] = useState(() => {\n    // Récupérer la police sauvegardée depuis localStorage\n    const savedFont = localStorage.getItem('editor-font') || 'system-ui, -apple-system, sans-serif';\n    return {\n      bold: false,\n      italic: false,\n      color: '#000000',\n      fontSize: '16px',\n      fontFamily: savedFont,\n      heading: null,\n      list: null\n    };\n  });\n\n  // État pour gérer l'image sélectionnée\n  const [selectedImage, setSelectedImage] = useState(null);\n\n  // Mémoriser le dernier formatage appliqué pour les débuts de ligne\n  const lastAppliedFormatRef = useRef(null);\n  \n  const editorRef = useRef(null);\n  const selectionRef = useRef(null);\n  const ignoreSelectionChangeRef = useRef(false);\n\n  // Sauvegarder la sélection\n  const saveSelection = useCallback(() => {\n    if (window.getSelection && editorRef.current) {\n      const selection = window.getSelection();\n      if (selection.rangeCount > 0) {\n        selectionRef.current = selection.getRangeAt(0).cloneRange();\n      }\n    }\n  }, []);\n\n  // Restaurer la sélection\n  const restoreSelection = useCallback(() => {\n    if (selectionRef.current && editorRef.current) {\n      const selection = window.getSelection();\n      selection.removeAllRanges();\n      selection.addRange(selectionRef.current);\n      editorRef.current.focus();\n    }\n  }, []);\n\n  // Détecter l'état de formatage à la position du curseur\n  const updateCurrentFormat = useCallback(() => {\n    if (!editorRef.current) return;\n\n    const selection = window.getSelection();\n    if (!selection.rangeCount) return;\n\n    const range = selection.getRangeAt(0);\n    let element = range.startContainer;\n\n    // Si c'est un nœud texte, prendre le parent\n    if (element.nodeType === Node.TEXT_NODE) {\n      element = element.parentElement;\n    }\n\n    // Si pas d'élément ou curseur en début de ligne, utiliser l'état mémorisé\n    if (!element || element === editorRef.current) {\n      if (lastAppliedFormatRef.current) {\n        setCurrentFormat(lastAppliedFormatRef.current);\n        return;\n      }\n    }\n\n    // Si on vient d'appliquer un formatage Normal, le préserver\n    if (lastAppliedFormatRef.current && \n        lastAppliedFormatRef.current.heading === null && \n        lastAppliedFormatRef.current.bold === false &&\n        lastAppliedFormatRef.current.italic === false) {\n      setCurrentFormat(lastAppliedFormatRef.current);\n      return;\n    }\n\n    // Parcourir vers le haut pour trouver les styles\n    let currentElement = element;\n    const newFormat = {\n      bold: false,\n      italic: false,\n      color: '#000000',\n      fontSize: '16px',\n      fontFamily: 'system-ui',\n      heading: null,\n      list: null\n    };\n\n    while (currentElement && currentElement !== editorRef.current) {\n      const computedStyle = window.getComputedStyle(currentElement);\n      const tagName = currentElement.tagName?.toLowerCase();\n\n\n      // Vérifier les balises de formatage\n      if (tagName === 'strong' || tagName === 'b' || computedStyle.fontWeight === 'bold' || parseInt(computedStyle.fontWeight) >= 700) {\n        newFormat.bold = true;\n      }\n      if (tagName === 'em' || tagName === 'i' || computedStyle.fontStyle === 'italic') {\n        newFormat.italic = true;\n      }\n      if (tagName?.match(/^h[1-6]$/)) {\n        newFormat.heading = tagName;\n      }\n      if (tagName === 'li') {\n        // Trouver le parent ul ou ol\n        let listParent = currentElement.parentElement;\n        while (listParent && !['ul', 'ol'].includes(listParent.tagName?.toLowerCase())) {\n          listParent = listParent.parentElement;\n        }\n        if (listParent) {\n          const parentTag = listParent.tagName.toLowerCase();\n          const listStyle = listParent.style.listStyleType;\n          if (parentTag === 'ul') {\n            newFormat.list = listStyle === 'lower-alpha' ? 'letter' : 'bullet';\n          } else if (parentTag === 'ol') {\n            newFormat.list = listStyle === 'lower-alpha' ? 'letter' : 'number';\n          }\n        }\n      }\n      if (tagName === 'ul') {\n        const listStyle = currentElement.style.listStyleType;\n        newFormat.list = listStyle === 'lower-alpha' ? 'letter' : 'bullet';\n      }\n      if (tagName === 'ol') {\n        const listStyle = currentElement.style.listStyleType;\n        newFormat.list = listStyle === 'lower-alpha' ? 'letter' : 'number';\n      }\n\n      // Vérifier les styles inline et computed\n      if (currentElement.style?.color) {\n        newFormat.color = currentElement.style.color;\n      } else if (computedStyle.color && computedStyle.color !== 'rgb(0, 0, 0)') {\n        newFormat.color = computedStyle.color;\n      }\n      if (currentElement.style?.fontSize) {\n        newFormat.fontSize = currentElement.style.fontSize;\n      }\n\n      currentElement = currentElement.parentElement;\n    }\n\n    // Convertir rgb en hex si nécessaire\n    if (newFormat.color.startsWith('rgb')) {\n      newFormat.color = rgbToHex(newFormat.color);\n    }\n\n    setCurrentFormat(newFormat);\n  }, []);\n\n  // Convertir RGB en HEX\n  const rgbToHex = (rgb) => {\n    const result = rgb.match(/\\d+/g);\n    if (!result || result.length < 3) return '#000000';\n    \n    const r = parseInt(result[0]);\n    const g = parseInt(result[1]);\n    const b = parseInt(result[2]);\n    \n    return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`;\n  };\n\n  // Gérer les changements de contenu\n  const handleInput = useCallback((e) => {\n    if (viewMode === 'wysiwyg') {\n      setContent(e.target.innerHTML);\n      // Laisser selectionchange gérer la synchronisation\n    } else {\n      setContent(e.target.value);\n    }\n  }, [viewMode]);\n\n  // Gérer les changements de sélection\n  const handleSelectionChange = useCallback(() => {\n    if (ignoreSelectionChangeRef.current) {\n      console.log('selectionchange IGNORED');\n      return;\n    }\n    if (viewMode === 'wysiwyg' && document.activeElement === editorRef.current) {\n      console.log('selectionchange PROCESSING');\n      updateCurrentFormat();\n      saveSelection();\n    }\n  }, [viewMode, updateCurrentFormat, saveSelection]);\n\n  // Fonction pour changer de vue avec conversion automatique\n  const changeViewMode = useCallback((newMode) => {\n    if (newMode === viewMode) return;\n    \n    let newContent = content;\n    \n    // Conversions entre les vues\n    if (viewMode === 'wysiwyg' && newMode === 'markdown') {\n      newContent = htmlToMarkdown(content);\n    } else if (viewMode === 'markdown' && newMode === 'wysiwyg') {\n      newContent = markdownToHtml(content);\n    } else if (viewMode === 'html' && newMode === 'markdown') {\n      newContent = htmlToMarkdown(content);\n    } else if (viewMode === 'markdown' && newMode === 'html') {\n      newContent = markdownToHtml(content);\n    }\n    // wysiwyg -> html : nettoyer les data-attributes\n    if (viewMode === 'wysiwyg' && newMode === 'html') {\n      newContent = content.replace(/ data-type=\"[^\"]*\"/g, '')\n                         .replace(/ data-number=\"[^\"]*\"/g, '')\n                         .replace(/ data-letter=\"[^\"]*\"/g, '');\n    }\n    // html -> wysiwyg : pas de conversion nécessaire\n    \n    setContent(newContent);\n    setViewMode(newMode);\n  }, [viewMode, content]);\n\n  // Écouter les changements de sélection\n  useEffect(() => {\n    document.addEventListener('selectionchange', handleSelectionChange);\n    return () => {\n      document.removeEventListener('selectionchange', handleSelectionChange);\n    };\n  }, [handleSelectionChange]);\n\n  // Sauvegarder la police sélectionnée dans localStorage\n  useEffect(() => {\n    if (currentFormat.fontFamily) {\n      localStorage.setItem('editor-font', currentFormat.fontFamily);\n    }\n  }, [currentFormat.fontFamily]);\n\n  // Fonction pour sauvegarder l'état appliqué\n  const saveAppliedFormat = useCallback((format) => {\n    lastAppliedFormatRef.current = { ...format };\n  }, []);\n\n  // Gestionnaire pour sélectionner une image\n  const handleImageClick = useCallback((imageElement) => {\n    if (viewMode === 'wysiwyg') {\n      setSelectedImage(imageElement);\n      // Déselectionner le texte pour éviter les conflits\n      window.getSelection().removeAllRanges();\n    }\n  }, [viewMode]);\n\n  // Gestionnaire pour désélectionner l'image si clic ailleurs\n  const handleEditorClick = useCallback((e) => {\n    if (viewMode === 'wysiwyg' && selectedImage) {\n      // Si le clic n'est pas sur l'image sélectionnée, la désélectionner\n      if (e.target !== selectedImage && !selectedImage.contains(e.target)) {\n        setSelectedImage(null);\n      }\n    }\n  }, [viewMode, selectedImage]);\n\n  // Gestionnaire complet pour tous les événements clavier des images\n  const handleImageKeyboardEvents = useCallback((e) => {\n    if (viewMode !== 'wysiwyg' || !selectedImage) return;\n\n    switch (e.key) {\n      case 'Delete':\n      case 'Backspace':\n        e.preventDefault();\n        // Supprimer l'image du DOM (wrapper complet si présent)\n        const wrapper = selectedImage.closest('.resizable-image, .image-block');\n        const elementToRemove = wrapper || selectedImage;\n        \n        // Sauvegarder la position pour navigation\n        const nextElement = elementToRemove.nextElementSibling;\n        const prevElement = elementToRemove.previousElementSibling;\n        \n        elementToRemove.remove();\n        setSelectedImage(null);\n        \n        // Placer le curseur après suppression\n        setTimeout(() => {\n          if (nextElement) {\n            const range = document.createRange();\n            const selection = window.getSelection();\n            range.setStart(nextElement, 0);\n            range.collapse(true);\n            selection.removeAllRanges();\n            selection.addRange(range);\n          } else if (prevElement) {\n            const range = document.createRange();\n            const selection = window.getSelection();\n            range.setStartAfter(prevElement);\n            range.collapse(true);\n            selection.removeAllRanges();\n            selection.addRange(range);\n          }\n          editorRef.current?.focus();\n        }, 10);\n        \n        // Déclencher la sauvegarde\n        if (editorRef.current) {\n          const event = new Event('input', { bubbles: true });\n          editorRef.current.dispatchEvent(event);\n        }\n        break;\n\n      case 'Enter':\n        e.preventDefault();\n        // Créer un nouveau paragraphe après l'image\n        const imageWrapper = selectedImage.closest('.resizable-image, .image-block');\n        const imageContainer = imageWrapper || selectedImage;\n        \n        // Créer un nouveau paragraphe\n        const newParagraph = document.createElement('p');\n        newParagraph.innerHTML = '<br>';\n        \n        // Insérer après l'image\n        targetElement.parentNode.insertBefore(newParagraph, targetElement.nextSibling);\n        \n        // Placer le curseur dans le nouveau paragraphe\n        setTimeout(() => {\n          const range = document.createRange();\n          const selection = window.getSelection();\n          range.setStart(newParagraph, 0);\n          range.collapse(true);\n          selection.removeAllRanges();\n          selection.addRange(range);\n          editorRef.current?.focus();\n        }, 10);\n        \n        // Désélectionner l'image\n        setSelectedImage(null);\n        \n        // Déclencher la sauvegarde\n        if (editorRef.current) {\n          const event = new Event('input', { bubbles: true });\n          editorRef.current.dispatchEvent(event);\n        }\n        break;\n\n      case 'ArrowUp':\n      case 'ArrowDown':\n        e.preventDefault();\n        // Navigation entre images et éléments\n        const currentWrapper = selectedImage.closest('.resizable-image, .image-block');\n        const currentElement = currentWrapper || selectedImage;\n        \n        let targetElement;\n        if (e.key === 'ArrowUp') {\n          targetElement = currentElement.previousElementSibling;\n        } else {\n          targetElement = currentElement.nextElementSibling;\n        }\n        \n        if (targetElement) {\n          // Si c'est une autre image, la sélectionner\n          const targetImage = targetElement.querySelector('img');\n          if (targetImage) {\n            setSelectedImage(targetImage);\n          } else {\n            // Sinon, placer le curseur dans l'élément\n            setSelectedImage(null);\n            setTimeout(() => {\n              const range = document.createRange();\n              const selection = window.getSelection();\n              if (e.key === 'ArrowUp') {\n                range.setStart(targetElement, targetElement.childNodes.length);\n              } else {\n                range.setStart(targetElement, 0);\n              }\n              range.collapse(true);\n              selection.removeAllRanges();\n              selection.addRange(range);\n              editorRef.current?.focus();\n            }, 10);\n          }\n        }\n        break;\n\n      case 'Escape':\n        e.preventDefault();\n        // Désélectionner l'image\n        setSelectedImage(null);\n        editorRef.current?.focus();\n        break;\n\n      default:\n        // Pour les autres touches, ne rien faire\n        break;\n    }\n  }, [viewMode, selectedImage]);\n\n  return {\n    content,\n    setContent,\n    viewMode,\n    setViewMode,\n    changeViewMode,\n    // Compatibilité avec l'ancien système\n    isWysiwyg: viewMode === 'wysiwyg',\n    setIsWysiwyg: (value) => changeViewMode(value ? 'wysiwyg' : 'html'),\n    currentFormat,\n    setCurrentFormat,\n    editorRef,\n    handleInput,\n    saveSelection,\n    restoreSelection,\n    updateCurrentFormat,\n    saveAppliedFormat,\n    ignoreSelectionChangeRef,\n    // Gestion de sélection d'images\n    selectedImage,\n    setSelectedImage,\n    handleImageClick,\n    handleEditorClick,\n    handleImageKeyboardEvents\n  };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}