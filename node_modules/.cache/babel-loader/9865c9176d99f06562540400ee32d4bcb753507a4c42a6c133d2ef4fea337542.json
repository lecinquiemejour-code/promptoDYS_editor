{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useCallback, useEffect, useRef } from 'react';\n\n/**\n * Hook pour le stockage unifi√© dans IndexedDB\n * Remplace localStorage + IndexedDB s√©par√©s\n * Structure:\n * - Store \"documents\": contenu HTML, mode vue, m√©tadonn√©es\n * - Store \"images\": images binaires avec m√©tadonn√©es\n */\nconst useIndexedStorage = () => {\n  _s();\n  const [database, setDatabase] = useState(null);\n  const [isInitialized, setIsInitialized] = useState(false);\n  // Cache pour √©viter la re-conversion blob: ‚Üí indexed://\n  const conversionCache = useRef(new Map());\n\n  // Configuration IndexedDB\n  const DB_NAME = 'EditorStorage';\n  const DB_VERSION = 2; // Incr√©ment√© pour forcer cr√©ation du store images\n  const DOCUMENT_STORE = 'documents';\n  const IMAGE_STORE = 'images';\n  const CURRENT_DOC_ID = 'current';\n\n  // üîß Initialisation automatique d'IndexedDB au d√©marrage\n  useEffect(() => {\n    const autoInit = async () => {\n      if (!isInitialized) {\n        console.log('üöÄ Initialisation automatique d\\'IndexedDB au d√©marrage');\n        try {\n          await initDB();\n        } catch (error) {\n          console.error('‚ùå Erreur initialisation automatique:', error);\n        }\n      }\n    };\n    autoInit();\n  }, []); // Vide pour ne s'ex√©cuter qu'une fois au montage\n\n  /**\n   * Initialiser la base de donn√©es IndexedDB\n   */\n  const initDB = useCallback(() => {\n    return new Promise((resolve, reject) => {\n      if (isInitialized && database) {\n        resolve(database);\n        return;\n      }\n      console.log('üîß Initialisation IndexedDB EditorStorage');\n      const request = indexedDB.open(DB_NAME, DB_VERSION);\n      request.onerror = () => {\n        console.error('‚ùå Erreur ouverture IndexedDB:', request.error);\n        reject(request.error);\n      };\n      request.onsuccess = () => {\n        console.log('‚úÖ IndexedDB EditorStorage initialis√©');\n        const db = request.result;\n        setDatabase(db);\n        setIsInitialized(true);\n        resolve(db);\n      };\n      request.onupgradeneeded = event => {\n        const db = event.target.result;\n\n        // Cr√©er le store des documents si n√©cessaire\n        if (!db.objectStoreNames.contains(DOCUMENT_STORE)) {\n          console.log('üìÑ Cr√©ation store documents');\n          const documentStore = db.createObjectStore(DOCUMENT_STORE, {\n            keyPath: 'id'\n          });\n          documentStore.createIndex('lastModified', 'lastModified', {\n            unique: false\n          });\n        }\n\n        // Cr√©er le store des images si n√©cessaire  \n        if (!db.objectStoreNames.contains(IMAGE_STORE)) {\n          console.log('üñºÔ∏è Cr√©ation store images');\n          const imageStore = db.createObjectStore(IMAGE_STORE, {\n            keyPath: 'id'\n          });\n          imageStore.createIndex('fileName', 'fileName', {\n            unique: false\n          });\n          imageStore.createIndex('uploadDate', 'uploadDate', {\n            unique: false\n          });\n        }\n        console.log('üèóÔ∏è Sch√©ma IndexedDB cr√©√©/mis √† jour');\n      };\n    });\n  }, [database, isInitialized]);\n\n  /**\n   * Sauvegarder le document courant\n   */\n  const saveDocument = useCallback(async (htmlContent, viewMode = 'wysiwyg', metadata = {}) => {\n    try {\n      const db = await initDB();\n      const transaction = db.transaction([DOCUMENT_STORE], 'readwrite');\n      const store = transaction.objectStore(DOCUMENT_STORE);\n      const document = {\n        id: CURRENT_DOC_ID,\n        htmlContent,\n        viewMode,\n        lastModified: new Date().toISOString(),\n        wordCount: htmlContent.replace(/<[^>]*>/g, '').split(/\\s+/).filter(w => w.length > 0).length,\n        ...metadata\n      };\n      await new Promise((resolve, reject) => {\n        const request = store.put(document);\n        request.onsuccess = () => {\n          console.log('üíæ Document sauvegard√© dans IndexedDB');\n          resolve();\n        };\n        request.onerror = () => {\n          console.error('‚ùå Erreur sauvegarde document:', request.error);\n          reject(request.error);\n        };\n      });\n    } catch (error) {\n      console.error('‚ùå Erreur saveDocument:', error);\n      throw error;\n    }\n  }, [initDB]);\n\n  /**\n   * Charger le document courant\n   */\n  const loadDocument = useCallback(async () => {\n    try {\n      const db = await initDB();\n      const transaction = db.transaction([DOCUMENT_STORE], 'readonly');\n      const store = transaction.objectStore(DOCUMENT_STORE);\n      const document = await new Promise((resolve, reject) => {\n        const request = store.get(CURRENT_DOC_ID);\n        request.onsuccess = () => {\n          console.log('üì• Document charg√© depuis IndexedDB');\n          resolve(request.result);\n        };\n        request.onerror = () => {\n          console.error('‚ùå Erreur chargement document:', request.error);\n          reject(request.error);\n        };\n      });\n      return document || null;\n    } catch (error) {\n      console.error('‚ùå Erreur loadDocument:', error);\n      return null;\n    }\n  }, [initDB]);\n\n  /**\n   * Sauvegarder une image\n   */\n  const saveImage = useCallback(async (imageId, blob, fileName, mimeType) => {\n    try {\n      const db = await initDB();\n      const transaction = db.transaction([IMAGE_STORE], 'readwrite');\n      const store = transaction.objectStore(IMAGE_STORE);\n      const imageData = {\n        id: imageId,\n        blob,\n        fileName,\n        mimeType,\n        size: blob.size,\n        uploadDate: new Date().toISOString()\n      };\n      await new Promise((resolve, reject) => {\n        const request = store.put(imageData);\n        request.onsuccess = () => {\n          console.log('üñºÔ∏è Image sauvegard√©e:', imageId, fileName);\n          resolve();\n        };\n        request.onerror = () => {\n          console.error('‚ùå Erreur sauvegarde image:', request.error);\n          reject(request.error);\n        };\n      });\n    } catch (error) {\n      console.error('‚ùå Erreur saveImage:', error);\n      throw error;\n    }\n  }, [initDB]);\n\n  /**\n   * Charger une image par ID\n   */\n  const loadImage = useCallback(async imageId => {\n    try {\n      const db = await initDB();\n      const transaction = db.transaction([IMAGE_STORE], 'readonly');\n      const store = transaction.objectStore(IMAGE_STORE);\n      const imageData = await new Promise((resolve, reject) => {\n        const request = store.get(imageId);\n        request.onsuccess = () => {\n          resolve(request.result);\n        };\n        request.onerror = () => {\n          console.error('‚ùå Erreur chargement image:', request.error);\n          reject(request.error);\n        };\n      });\n      if (imageData) {\n        // Cr√©er l'URL blob pour l'affichage\n        const blobUrl = URL.createObjectURL(imageData.blob);\n        console.log('‚úÖ Image charg√©e et blob URL cr√©√©e:', imageId, '‚Üí', blobUrl);\n        return {\n          blobUrl,\n          fileName: imageData.fileName,\n          mimeType: imageData.mimeType,\n          size: imageData.size\n        };\n      }\n      return null;\n    } catch (error) {\n      console.error('‚ùå Erreur loadImage:', error);\n      return null;\n    }\n  }, [initDB]);\n\n  /**\n   * Convertir le contenu HTML: remplacer indexed:// par des blob: URLs\n   */\n  const convertContentForDisplay = useCallback(async htmlContent => {\n    if (!htmlContent || !htmlContent.includes('indexed://')) {\n      return htmlContent;\n    }\n    console.log('üîÑ Conversion indexed:// ‚Üí blob: URLs pour affichage');\n\n    // Parser le HTML\n    const tempDiv = document.createElement('div');\n    tempDiv.innerHTML = htmlContent;\n\n    // Trouver toutes les images indexed://\n    const images = tempDiv.querySelectorAll('img[src^=\"indexed://\"]');\n    for (const img of images) {\n      const indexedUrl = img.src;\n      const imageId = indexedUrl.replace('indexed://', '');\n      console.log('üîÑ Conversion:', imageId);\n      const imageData = await loadImage(imageId);\n      if (imageData) {\n        img.src = imageData.blobUrl;\n        // Ajouter les m√©tadonn√©es manquantes si n√©cessaire\n        if (!img.alt && imageData.fileName) {\n          img.alt = imageData.fileName;\n        }\n        console.log('‚úÖ Converti:', imageId, '‚Üí', imageData.blobUrl.substring(0, 50) + '...');\n      } else {\n        console.warn('‚ö†Ô∏è Image non trouv√©e pour:', imageId);\n      }\n    }\n    return tempDiv.innerHTML;\n  }, [loadImage]);\n\n  /**\n   * Convertir le contenu HTML: remplacer blob: par des indexed:// URLs pour sauvegarde\n   */\n  const convertContentForStorage = useCallback(async htmlContent => {\n    if (!htmlContent || !htmlContent.includes('blob:')) {\n      return htmlContent;\n    }\n\n    // Parser le HTML\n    const tempDiv = document.createElement('div');\n    tempDiv.innerHTML = htmlContent;\n    const images = tempDiv.querySelectorAll('img[src^=\"blob:\"]');\n    if (images.length === 0) {\n      return htmlContent;\n    }\n    console.log(`üîÑ Conversion blob: ‚Üí indexed:// URLs pour sauvegarde (${images.length} images)`);\n    for (const img of images) {\n      const blobUrl = img.src;\n      try {\n        // V√©rifier le cache d'abord\n        if (conversionCache.current.has(blobUrl)) {\n          const cachedImageId = conversionCache.current.get(blobUrl);\n          img.src = `indexed://${cachedImageId}`;\n          console.log(`üéØ Image depuis cache: ${cachedImageId}`);\n          continue;\n        }\n\n        // R√©cup√©rer le blob depuis l'URL\n        const response = await fetch(blobUrl);\n        const blob = await response.blob();\n\n        // G√©n√©rer un ID unique pour l'image\n        const imageId = `img_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n        const fileName = img.alt || `image_${imageId}.${blob.type.split('/')[1] || 'jpg'}`;\n\n        // Sauvegarder l'image dans IndexedDB\n        await saveImage(imageId, blob, fileName);\n\n        // Ajouter au cache pour √©viter les re-conversions\n        conversionCache.current.set(blobUrl, imageId);\n\n        // Remplacer l'URL blob: par indexed://\n        img.src = `indexed://${imageId}`;\n        console.log(`üìù Image convertie et mise en cache: blob: ‚Üí indexed://${imageId}`);\n      } catch (error) {\n        console.error('‚ùå Erreur conversion image pour sauvegarde:', error);\n        // Garder l'URL blob: en cas d'erreur\n      }\n    }\n    return tempDiv.innerHTML;\n  }, [saveImage]); // Pas besoin d'ajouter conversionCache dans les deps (useRef)\n\n  /**\n   * Lister toutes les images stock√©es\n   */\n  const listAllImages = useCallback(async () => {\n    try {\n      const db = await initDB();\n      const transaction = db.transaction([IMAGE_STORE], 'readonly');\n      const store = transaction.objectStore(IMAGE_STORE);\n      const images = await new Promise((resolve, reject) => {\n        const request = store.getAll();\n        request.onsuccess = () => {\n          resolve(request.result);\n        };\n        request.onerror = () => {\n          reject(request.error);\n        };\n      });\n      console.log('üìã Images disponibles:', images.length);\n      return images;\n    } catch (error) {\n      console.error('‚ùå Erreur listAllImages:', error);\n      return [];\n    }\n  }, [initDB]);\n  return {\n    // √âtats\n    isInitialized,\n    // M√©thodes document\n    saveDocument,\n    loadDocument,\n    // M√©thodes image\n    saveImage,\n    loadImage,\n    listAllImages,\n    // Utilitaires\n    convertContentForDisplay,\n    convertContentForStorage\n  };\n};\n_s(useIndexedStorage, \"Coc9T1dht6ipH5v+8n1LISkUowM=\");\nexport default useIndexedStorage;","map":{"version":3,"names":["useState","useCallback","useEffect","useRef","useIndexedStorage","_s","database","setDatabase","isInitialized","setIsInitialized","conversionCache","Map","DB_NAME","DB_VERSION","DOCUMENT_STORE","IMAGE_STORE","CURRENT_DOC_ID","autoInit","console","log","initDB","error","Promise","resolve","reject","request","indexedDB","open","onerror","onsuccess","db","result","onupgradeneeded","event","target","objectStoreNames","contains","documentStore","createObjectStore","keyPath","createIndex","unique","imageStore","saveDocument","htmlContent","viewMode","metadata","transaction","store","objectStore","document","id","lastModified","Date","toISOString","wordCount","replace","split","filter","w","length","put","loadDocument","get","saveImage","imageId","blob","fileName","mimeType","imageData","size","uploadDate","loadImage","blobUrl","URL","createObjectURL","convertContentForDisplay","includes","tempDiv","createElement","innerHTML","images","querySelectorAll","img","indexedUrl","src","alt","substring","warn","convertContentForStorage","current","has","cachedImageId","response","fetch","now","Math","random","toString","substr","type","set","listAllImages","getAll"],"sources":["C:/Users/JEAN-NOELLEFEBVRE-SA/CascadeProjects/editor/src/hooks/useIndexedStorage.js"],"sourcesContent":["import { useState, useCallback, useEffect, useRef } from 'react';\n\n/**\n * Hook pour le stockage unifi√© dans IndexedDB\n * Remplace localStorage + IndexedDB s√©par√©s\n * Structure:\n * - Store \"documents\": contenu HTML, mode vue, m√©tadonn√©es\n * - Store \"images\": images binaires avec m√©tadonn√©es\n */\nconst useIndexedStorage = () => {\n  const [database, setDatabase] = useState(null);\n  const [isInitialized, setIsInitialized] = useState(false);\n  // Cache pour √©viter la re-conversion blob: ‚Üí indexed://\n  const conversionCache = useRef(new Map());\n\n  // Configuration IndexedDB\n  const DB_NAME = 'EditorStorage';\n  const DB_VERSION = 2; // Incr√©ment√© pour forcer cr√©ation du store images\n  const DOCUMENT_STORE = 'documents';\n  const IMAGE_STORE = 'images';\n  const CURRENT_DOC_ID = 'current';\n\n  // üîß Initialisation automatique d'IndexedDB au d√©marrage\n  useEffect(() => {\n    const autoInit = async () => {\n      if (!isInitialized) {\n        console.log('üöÄ Initialisation automatique d\\'IndexedDB au d√©marrage');\n        try {\n          await initDB();\n        } catch (error) {\n          console.error('‚ùå Erreur initialisation automatique:', error);\n        }\n      }\n    };\n    \n    autoInit();\n  }, []); // Vide pour ne s'ex√©cuter qu'une fois au montage\n\n  /**\n   * Initialiser la base de donn√©es IndexedDB\n   */\n  const initDB = useCallback(() => {\n    return new Promise((resolve, reject) => {\n      if (isInitialized && database) {\n        resolve(database);\n        return;\n      }\n\n      console.log('üîß Initialisation IndexedDB EditorStorage');\n      const request = indexedDB.open(DB_NAME, DB_VERSION);\n\n      request.onerror = () => {\n        console.error('‚ùå Erreur ouverture IndexedDB:', request.error);\n        reject(request.error);\n      };\n\n      request.onsuccess = () => {\n        console.log('‚úÖ IndexedDB EditorStorage initialis√©');\n        const db = request.result;\n        setDatabase(db);\n        setIsInitialized(true);\n        resolve(db);\n      };\n\n      request.onupgradeneeded = (event) => {\n        const db = event.target.result;\n        \n        // Cr√©er le store des documents si n√©cessaire\n        if (!db.objectStoreNames.contains(DOCUMENT_STORE)) {\n          console.log('üìÑ Cr√©ation store documents');\n          const documentStore = db.createObjectStore(DOCUMENT_STORE, { keyPath: 'id' });\n          documentStore.createIndex('lastModified', 'lastModified', { unique: false });\n        }\n\n        // Cr√©er le store des images si n√©cessaire  \n        if (!db.objectStoreNames.contains(IMAGE_STORE)) {\n          console.log('üñºÔ∏è Cr√©ation store images');\n          const imageStore = db.createObjectStore(IMAGE_STORE, { keyPath: 'id' });\n          imageStore.createIndex('fileName', 'fileName', { unique: false });\n          imageStore.createIndex('uploadDate', 'uploadDate', { unique: false });\n        }\n\n        console.log('üèóÔ∏è Sch√©ma IndexedDB cr√©√©/mis √† jour');\n      };\n    });\n  }, [database, isInitialized]);\n\n  /**\n   * Sauvegarder le document courant\n   */\n  const saveDocument = useCallback(async (htmlContent, viewMode = 'wysiwyg', metadata = {}) => {\n    try {\n      const db = await initDB();\n      const transaction = db.transaction([DOCUMENT_STORE], 'readwrite');\n      const store = transaction.objectStore(DOCUMENT_STORE);\n\n      const document = {\n        id: CURRENT_DOC_ID,\n        htmlContent,\n        viewMode,\n        lastModified: new Date().toISOString(),\n        wordCount: htmlContent.replace(/<[^>]*>/g, '').split(/\\s+/).filter(w => w.length > 0).length,\n        ...metadata\n      };\n\n      await new Promise((resolve, reject) => {\n        const request = store.put(document);\n        request.onsuccess = () => {\n          console.log('üíæ Document sauvegard√© dans IndexedDB');\n          resolve();\n        };\n        request.onerror = () => {\n          console.error('‚ùå Erreur sauvegarde document:', request.error);\n          reject(request.error);\n        };\n      });\n\n    } catch (error) {\n      console.error('‚ùå Erreur saveDocument:', error);\n      throw error;\n    }\n  }, [initDB]);\n\n  /**\n   * Charger le document courant\n   */\n  const loadDocument = useCallback(async () => {\n    try {\n      const db = await initDB();\n      const transaction = db.transaction([DOCUMENT_STORE], 'readonly');\n      const store = transaction.objectStore(DOCUMENT_STORE);\n\n      const document = await new Promise((resolve, reject) => {\n        const request = store.get(CURRENT_DOC_ID);\n        request.onsuccess = () => {\n          console.log('üì• Document charg√© depuis IndexedDB');\n          resolve(request.result);\n        };\n        request.onerror = () => {\n          console.error('‚ùå Erreur chargement document:', request.error);\n          reject(request.error);\n        };\n      });\n\n      return document || null;\n\n    } catch (error) {\n      console.error('‚ùå Erreur loadDocument:', error);\n      return null;\n    }\n  }, [initDB]);\n\n  /**\n   * Sauvegarder une image\n   */\n  const saveImage = useCallback(async (imageId, blob, fileName, mimeType) => {\n    try {\n      const db = await initDB();\n      const transaction = db.transaction([IMAGE_STORE], 'readwrite');\n      const store = transaction.objectStore(IMAGE_STORE);\n\n      const imageData = {\n        id: imageId,\n        blob,\n        fileName,\n        mimeType,\n        size: blob.size,\n        uploadDate: new Date().toISOString()\n      };\n\n      await new Promise((resolve, reject) => {\n        const request = store.put(imageData);\n        request.onsuccess = () => {\n          console.log('üñºÔ∏è Image sauvegard√©e:', imageId, fileName);\n          resolve();\n        };\n        request.onerror = () => {\n          console.error('‚ùå Erreur sauvegarde image:', request.error);\n          reject(request.error);\n        };\n      });\n\n    } catch (error) {\n      console.error('‚ùå Erreur saveImage:', error);\n      throw error;\n    }\n  }, [initDB]);\n\n  /**\n   * Charger une image par ID\n   */\n  const loadImage = useCallback(async (imageId) => {\n    try {\n      const db = await initDB();\n      const transaction = db.transaction([IMAGE_STORE], 'readonly');\n      const store = transaction.objectStore(IMAGE_STORE);\n\n      const imageData = await new Promise((resolve, reject) => {\n        const request = store.get(imageId);\n        request.onsuccess = () => {\n          resolve(request.result);\n        };\n        request.onerror = () => {\n          console.error('‚ùå Erreur chargement image:', request.error);\n          reject(request.error);\n        };\n      });\n\n      if (imageData) {\n        // Cr√©er l'URL blob pour l'affichage\n        const blobUrl = URL.createObjectURL(imageData.blob);\n        console.log('‚úÖ Image charg√©e et blob URL cr√©√©e:', imageId, '‚Üí', blobUrl);\n        \n        return {\n          blobUrl,\n          fileName: imageData.fileName,\n          mimeType: imageData.mimeType,\n          size: imageData.size\n        };\n      }\n\n      return null;\n\n    } catch (error) {\n      console.error('‚ùå Erreur loadImage:', error);\n      return null;\n    }\n  }, [initDB]);\n\n  /**\n   * Convertir le contenu HTML: remplacer indexed:// par des blob: URLs\n   */\n  const convertContentForDisplay = useCallback(async (htmlContent) => {\n    if (!htmlContent || !htmlContent.includes('indexed://')) {\n      return htmlContent;\n    }\n\n    console.log('üîÑ Conversion indexed:// ‚Üí blob: URLs pour affichage');\n    \n    // Parser le HTML\n    const tempDiv = document.createElement('div');\n    tempDiv.innerHTML = htmlContent;\n    \n    // Trouver toutes les images indexed://\n    const images = tempDiv.querySelectorAll('img[src^=\"indexed://\"]');\n    \n    for (const img of images) {\n      const indexedUrl = img.src;\n      const imageId = indexedUrl.replace('indexed://', '');\n      \n      console.log('üîÑ Conversion:', imageId);\n      const imageData = await loadImage(imageId);\n      \n      if (imageData) {\n        img.src = imageData.blobUrl;\n        // Ajouter les m√©tadonn√©es manquantes si n√©cessaire\n        if (!img.alt && imageData.fileName) {\n          img.alt = imageData.fileName;\n        }\n        console.log('‚úÖ Converti:', imageId, '‚Üí', imageData.blobUrl.substring(0, 50) + '...');\n      } else {\n        console.warn('‚ö†Ô∏è Image non trouv√©e pour:', imageId);\n      }\n    }\n    \n    return tempDiv.innerHTML;\n  }, [loadImage]);\n\n  /**\n   * Convertir le contenu HTML: remplacer blob: par des indexed:// URLs pour sauvegarde\n   */\n  const convertContentForStorage = useCallback(async (htmlContent) => {\n    if (!htmlContent || !htmlContent.includes('blob:')) {\n      return htmlContent;\n    }\n\n    // Parser le HTML\n    const tempDiv = document.createElement('div');\n    tempDiv.innerHTML = htmlContent;\n    const images = tempDiv.querySelectorAll('img[src^=\"blob:\"]');\n    \n    if (images.length === 0) {\n      return htmlContent;\n    }\n\n    console.log(`üîÑ Conversion blob: ‚Üí indexed:// URLs pour sauvegarde (${images.length} images)`);\n    \n    for (const img of images) {\n      const blobUrl = img.src;\n      \n      try {\n        // V√©rifier le cache d'abord\n        if (conversionCache.current.has(blobUrl)) {\n          const cachedImageId = conversionCache.current.get(blobUrl);\n          img.src = `indexed://${cachedImageId}`;\n          console.log(`üéØ Image depuis cache: ${cachedImageId}`);\n          continue;\n        }\n        \n        // R√©cup√©rer le blob depuis l'URL\n        const response = await fetch(blobUrl);\n        const blob = await response.blob();\n        \n        // G√©n√©rer un ID unique pour l'image\n        const imageId = `img_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n        const fileName = img.alt || `image_${imageId}.${blob.type.split('/')[1] || 'jpg'}`;\n        \n        // Sauvegarder l'image dans IndexedDB\n        await saveImage(imageId, blob, fileName);\n        \n        // Ajouter au cache pour √©viter les re-conversions\n        conversionCache.current.set(blobUrl, imageId);\n        \n        // Remplacer l'URL blob: par indexed://\n        img.src = `indexed://${imageId}`;\n        \n        console.log(`üìù Image convertie et mise en cache: blob: ‚Üí indexed://${imageId}`);\n        \n      } catch (error) {\n        console.error('‚ùå Erreur conversion image pour sauvegarde:', error);\n        // Garder l'URL blob: en cas d'erreur\n      }\n    }\n    \n    return tempDiv.innerHTML;\n  }, [saveImage]); // Pas besoin d'ajouter conversionCache dans les deps (useRef)\n\n  /**\n   * Lister toutes les images stock√©es\n   */\n  const listAllImages = useCallback(async () => {\n    try {\n      const db = await initDB();\n      const transaction = db.transaction([IMAGE_STORE], 'readonly');\n      const store = transaction.objectStore(IMAGE_STORE);\n\n      const images = await new Promise((resolve, reject) => {\n        const request = store.getAll();\n        request.onsuccess = () => {\n          resolve(request.result);\n        };\n        request.onerror = () => {\n          reject(request.error);\n        };\n      });\n\n      console.log('üìã Images disponibles:', images.length);\n      return images;\n\n    } catch (error) {\n      console.error('‚ùå Erreur listAllImages:', error);\n      return [];\n    }\n  }, [initDB]);\n\n  return {\n    // √âtats\n    isInitialized,\n    \n    // M√©thodes document\n    saveDocument,\n    loadDocument,\n    \n    // M√©thodes image\n    saveImage,\n    loadImage,\n    listAllImages,\n    \n    // Utilitaires\n    convertContentForDisplay,\n    convertContentForStorage\n  };\n};\n\nexport default useIndexedStorage;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}