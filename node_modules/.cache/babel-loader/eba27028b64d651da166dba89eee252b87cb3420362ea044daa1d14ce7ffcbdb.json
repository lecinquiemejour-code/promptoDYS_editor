{"ast":null,"code":"/**\n * Gestionnaire pour le systÃ¨me de fichiers PromptoDYS\n * GÃ¨re l'organisation des documents et images dans une structure cohÃ©rente\n */\n\n/**\n * VÃ©rifie si la File System Access API est disponible\n */\nexport const isFileSystemAccessSupported = () => {\n  return typeof window !== 'undefined' && 'showDirectoryPicker' in window;\n};\n\n/**\n * GÃ©nÃ¨re un nom de dossier basÃ© sur un timestamp\n * Format: Document_YYYYMMDD_HHMM\n */\nexport const generateTimestampFolderName = () => {\n  const now = new Date();\n  const year = now.getFullYear();\n  const month = String(now.getMonth() + 1).padStart(2, '0');\n  const day = String(now.getDate()).padStart(2, '0');\n  const hours = String(now.getHours()).padStart(2, '0');\n  const minutes = String(now.getMinutes()).padStart(2, '0');\n  return `Document_${year}${month}${day}_${hours}${minutes}`;\n};\n\n/**\n * GÃ©nÃ¨re un nom de fichier image unique avec timestamp\n */\nexport const generateImageFileName = (originalName, extension) => {\n  const now = new Date();\n  const timestamp = now.getFullYear().toString() + String(now.getMonth() + 1).padStart(2, '0') + String(now.getDate()).padStart(2, '0') + '_' + String(now.getHours()).padStart(2, '0') + String(now.getMinutes()).padStart(2, '0') + String(now.getSeconds()).padStart(2, '0');\n  const baseName = originalName.replace(/\\.[^/.]+$/, \"\") || 'image';\n  return `${baseName}_${timestamp}.${extension}`;\n};\n\n/**\n * Ã‰tat global du rÃ©pertoire de travail actuel\n */\nlet currentProjectDirectory = null;\nlet currentProjectName = null;\n\n/**\n * DÃ©finit le document PromptoDYS actuel\n */\nexport const setCurrentProject = (documentHandle, documentName) => {\n  currentProjectDirectory = documentHandle;\n  currentProjectName = documentName;\n\n  // Sauvegarder en localStorage pour persistance\n  if (documentName) {\n    localStorage.setItem('currentPromptoDysProject', documentName);\n    localStorage.setItem('promptoDysConnected', 'true');\n    console.log('ðŸ’¾ Document sauvÃ© en localStorage:', documentName);\n  }\n};\n\n/**\n * RÃ©cupÃ¨re le document PromptoDYS actuel\n */\nexport const getCurrentProject = () => {\n  return {\n    directory: currentProjectDirectory,\n    name: currentProjectName\n  };\n};\n\n/**\n * RÃ©cupÃ¨re le nom du dernier workspace PromptoDYS utilisÃ©\n */\nexport const getLastWorkspaceName = () => {\n  try {\n    const savedWorkspace = localStorage.getItem('promptoDysWorkspaceHandle');\n    if (savedWorkspace) {\n      const workspace = JSON.parse(savedWorkspace);\n      return workspace.name || null;\n    }\n  } catch (error) {\n    console.error('âŒ Erreur rÃ©cupÃ©ration nom workspace:', error);\n  }\n  return null;\n};\n\n/**\n * Initialise le workspace PromptoDYS\n * Demande Ã  l'utilisateur de sÃ©lectionner le dossier PromptoDYS\n */\nexport const initializePromptoDysWorkspace = async (skipDialog = false) => {\n  if (!isFileSystemAccessSupported()) {\n    throw new Error('File System Access API non supportÃ©e');\n  }\n\n  // Si skipDialog est true, essayer de restaurer le workspace existant\n  if (skipDialog) {\n    console.log('ðŸ” Tentative restauration workspace silencieuse...');\n    // Pour skipDialog, on ne peut pas demander de nouvelle sÃ©lection\n    // On retourne null pour signaler l'Ã©chec de restauration silencieuse\n    return null;\n  }\n  try {\n    // Demander Ã  l'utilisateur de sÃ©lectionner le dossier PromptoDYS\n    console.log('ðŸ—‚ï¸ SÃ©lection du dossier PromptoDYS...');\n    const promptoDysHandle = await window.showDirectoryPicker({\n      mode: 'readwrite',\n      startIn: 'documents'\n    });\n\n    // Sauvegarder la rÃ©fÃ©rence du workspace (sans crÃ©er de document)\n    localStorage.setItem('promptoDysWorkspaceHandle', JSON.stringify({\n      name: promptoDysHandle.name,\n      timestamp: new Date().toISOString()\n    }));\n    console.log('âœ… Workspace PromptoDYS configurÃ©:', promptoDysHandle.name);\n    return promptoDysHandle;\n  } catch (error) {\n    if (error.name === 'AbortError') {\n      throw new Error('SÃ©lection du dossier PromptoDYS annulÃ©e.');\n    } else {\n      console.error('âŒ Erreur initialisation PromptoDYS:', error);\n      throw error;\n    }\n  }\n};\n\n/**\n * CrÃ©e un nouveau document PromptoDYS avec un nom timestamp\n */\nexport const createPromptoDysDocument = async promptoDysDirectory => {\n  if (!promptoDysDirectory) {\n    // Tenter de rÃ©cupÃ©rer le workspace depuis initializePromptoDysWorkspace\n    try {\n      const workspace = await initializePromptoDysWorkspace();\n      promptoDysDirectory = workspace;\n    } catch (error) {\n      console.error('âŒ Impossible d\\'initialiser le workspace:', error);\n      return null;\n    }\n  }\n  try {\n    const documentName = generateTimestampFolderName();\n\n    // CrÃ©er le dossier du document\n    const documentHandle = await promptoDysDirectory.getDirectoryHandle(documentName, {\n      create: true\n    });\n\n    // CrÃ©er le dossier assets\n    await documentHandle.getDirectoryHandle('assets', {\n      create: true\n    });\n\n    // DÃ©finir comme document actuel\n    setCurrentProject(documentHandle, documentName);\n    console.log('âœ… Nouveau document PromptoDYS crÃ©Ã©:', documentName);\n    return documentHandle;\n  } catch (error) {\n    console.error('âŒ Erreur crÃ©ation document PromptoDYS:', error);\n    return null;\n  }\n};\n\n/**\n * CrÃ©e ou rÃ©cupÃ¨re un document PromptoDYS avec un nom personnalisÃ©\n */\nexport const createOrGetPromptoDysDocument = async (promptoDysDirectory, documentName) => {\n  if (!promptoDysDirectory) {\n    // Tenter de rÃ©cupÃ©rer le workspace depuis initializePromptoDysWorkspace\n    try {\n      const workspace = await initializePromptoDysWorkspace();\n      promptoDysDirectory = workspace;\n    } catch (error) {\n      console.error('âŒ Impossible d\\'initialiser le workspace:', error);\n      return null;\n    }\n  }\n  try {\n    // CrÃ©er ou rÃ©cupÃ©rer le dossier du document\n    const documentHandle = await promptoDysDirectory.getDirectoryHandle(documentName, {\n      create: true\n    });\n\n    // CrÃ©er le dossier assets s'il n'existe pas\n    await documentHandle.getDirectoryHandle('assets', {\n      create: true\n    });\n\n    // DÃ©finir comme document actuel\n    setCurrentProject(documentHandle, documentName);\n    console.log('âœ… Document PromptoDYS configurÃ©:', documentName);\n    return documentHandle;\n  } catch (error) {\n    console.error('âŒ Erreur configuration document PromptoDYS:', error);\n    return null;\n  }\n};\n\n/**\n * Sauvegarde une image dans le dossier assets du document actuel\n */\nexport const saveImageToPromptoDys = async (imageFile, documentDirectory) => {\n  if (!documentDirectory) return null;\n  try {\n    // Obtenir le dossier assets\n    const assetsHandle = await documentDirectory.getDirectoryHandle('assets', {\n      create: true\n    });\n\n    // GÃ©nÃ©rer un nom de fichier unique\n    const fileExtension = imageFile.name.split('.').pop().toLowerCase();\n    const fileName = generateImageFileName(imageFile.name, fileExtension);\n\n    // CrÃ©er le fichier image\n    const fileHandle = await assetsHandle.getFileHandle(fileName, {\n      create: true\n    });\n\n    // Ã‰crire les donnÃ©es\n    const writable = await fileHandle.createWritable();\n    await writable.write(imageFile);\n    await writable.close();\n    console.log('âœ… Image sauvegardÃ©e:', fileName);\n\n    // Retourner le chemin relatif pour Markdown\n    const relativePath = `./assets/${fileName}`;\n    console.log('ðŸ“ Image sauvÃ©e avec chemin relatif:', relativePath);\n    return relativePath;\n  } catch (error) {\n    console.error('âŒ Erreur sauvegarde image:', error);\n    return null;\n  }\n};\n\n/**\n * Sauvegarde le fichier Markdown dans le document PromptoDYS\n */\nexport const saveMarkdownToPromptoDys = async (content, documentDirectory, fileName) => {\n  if (!documentDirectory) return false;\n  try {\n    const mdFileName = fileName.endsWith('.md') ? fileName : `${fileName}.md`;\n    const fileHandle = await documentDirectory.getFileHandle(mdFileName, {\n      create: true\n    });\n    const writable = await fileHandle.createWritable();\n    await writable.write(content);\n    await writable.close();\n    console.log('âœ… Fichier Markdown sauvegardÃ©:', mdFileName);\n    return true;\n  } catch (error) {\n    console.error('âŒ Erreur sauvegarde Markdown:', error);\n    return false;\n  }\n};\n\n/**\n * Liste les documents PromptoDYS disponibles\n */\nexport const listPromptoDysDocuments = async promptoDysDirectory => {\n  if (!promptoDysDirectory) return [];\n  try {\n    const documents = [];\n    for await (const [name, handle] of promptoDysDirectory.entries()) {\n      if (handle.kind === 'directory' && name.startsWith('Document_')) {\n        // VÃ©rifier s'il y a un fichier .md dans le dossier\n        try {\n          let hasMarkdown = false;\n          for await (const [fileName, fileHandle] of handle.entries()) {\n            if (fileHandle.kind === 'file' && fileName.endsWith('.md')) {\n              hasMarkdown = true;\n              break;\n            }\n          }\n          if (hasMarkdown) {\n            documents.push({\n              name,\n              handle,\n              displayName: name.replace('Document_', '').replace(/_/g, '/')\n            });\n          }\n        } catch (error) {\n          // Ignorer les dossiers inaccessibles\n        }\n      }\n    }\n\n    // Trier par nom (plus rÃ©cent en premier)\n    return documents.sort((a, b) => b.name.localeCompare(a.name));\n  } catch (error) {\n    console.error('âŒ Erreur liste documents:', error);\n    return [];\n  }\n};\n\n/**\n * RÃ©initialise le document actuel (pour nouveau document)\n */\nexport const resetCurrentDocument = () => {\n  currentProjectDirectory = null;\n  currentProjectName = null;\n  localStorage.removeItem('currentPromptoDysProject');\n  localStorage.removeItem('promptoDysConnected');\n  console.log('ðŸ”„ Document PromptoDYS rÃ©initialisÃ©');\n};\n\n/**\n * VÃ©rifie si PromptoDYS Ã©tait connectÃ© prÃ©cÃ©demment\n */\nexport const isPromptoDysConnected = () => {\n  return localStorage.getItem('promptoDysConnected') === 'true';\n};\n\n/**\n * Tente de restaurer le workspace et document depuis localStorage\n */\nexport const restorePromptoDysState = async () => {\n  if (!isPromptoDysConnected()) {\n    return {\n      workspace: null,\n      document: null\n    };\n  }\n  try {\n    // Restaurer le workspace\n    const workspace = await initializePromptoDysWorkspace();\n    if (!workspace) {\n      return {\n        workspace: null,\n        document: null\n      };\n    }\n\n    // Restaurer le document actuel\n    const savedDocumentName = localStorage.getItem('currentPromptoDysProject');\n    if (savedDocumentName) {\n      try {\n        const documentHandle = await workspace.getDirectoryHandle(savedDocumentName);\n        setCurrentProject(documentHandle, savedDocumentName);\n        console.log('âœ… Document PromptoDYS restaurÃ©:', savedDocumentName);\n        return {\n          workspace,\n          document: documentHandle\n        };\n      } catch (error) {\n        console.warn('âš ï¸ Document sauvÃ© introuvable, en crÃ©er un nouveau:', savedDocumentName);\n      }\n    }\n    return {\n      workspace,\n      document: null\n    };\n  } catch (error) {\n    console.error('âŒ Erreur restauration PromptoDYS:', error);\n    // Nettoyer localStorage si restauration Ã©choue\n    localStorage.removeItem('promptoDysConnected');\n    localStorage.removeItem('currentPromptoDysProject');\n    return {\n      workspace: null,\n      document: null\n    };\n  }\n};\n\n/**\n * CrÃ©e automatiquement un document aprÃ¨s connexion workspace\n */\nexport const ensureCurrentDocument = async workspace => {\n  if (!workspace) return null;\n\n  // VÃ©rifier si on a dÃ©jÃ  un document actuel\n  const current = getCurrentProject();\n  if (current.directory) {\n    return current.directory;\n  }\n\n  // CrÃ©er un nouveau document\n  return await createPromptoDysDocument(workspace);\n};\n\n/**\n * Obtient une rÃ©fÃ©rence au workspace PromptoDYS principal\n */\nexport const getPromptoDysWorkspace = async () => {\n  try {\n    return await initializePromptoDysWorkspace();\n  } catch (error) {\n    console.error('âŒ Impossible d\\'obtenir le workspace PromptoDYS:', error);\n    return null;\n  }\n};\n\n/**\n * Convertit une URL relative PromptoDYS en Blob URL pour affichage\n */\nexport const convertPromptoDysUrlToBlob = async (relativeUrl, documentDirectory) => {\n  if (!relativeUrl || !documentDirectory || !relativeUrl.startsWith('./assets/')) {\n    return relativeUrl; // Retourner l'URL originale si pas une URL PromptoDYS\n  }\n  try {\n    // Extraire le nom de fichier depuis l'URL relative\n    const fileName = relativeUrl.replace('./assets/', '');\n\n    // AccÃ©der au dossier assets\n    const assetsHandle = await documentDirectory.getDirectoryHandle('assets');\n\n    // RÃ©cupÃ©rer le fichier\n    const fileHandle = await assetsHandle.getFileHandle(fileName);\n    const file = await fileHandle.getFile();\n\n    // CrÃ©er une Blob URL temporaire\n    const blobUrl = URL.createObjectURL(file);\n    console.log(`âœ… Blob URL crÃ©Ã©e: ${fileName} -> ${blobUrl}`);\n    return blobUrl;\n  } catch (error) {\n    console.error(`âŒ Erreur conversion Blob URL pour ${relativeUrl}:`, error);\n    return relativeUrl; // Fallback sur l'URL originale\n  }\n};\n\n/**\n * Convertit toutes les URLs relatives PromptoDYS en Blob URLs dans un contenu HTML\n */\nexport const convertAllPromptoDysUrlsToBlobs = async (htmlContent, documentDirectory) => {\n  if (!htmlContent || !documentDirectory) {\n    return htmlContent;\n  }\n\n  // Regex pour trouver toutes les URLs d'images PromptoDYS\n  const imageRegex = /<img[^>]+src=[\"']\\.\\/assets\\/([^\"']+)[\"'][^>]*>/g;\n  const matches = [...htmlContent.matchAll(imageRegex)];\n  if (matches.length === 0) {\n    return htmlContent; // Pas d'images PromptoDYS trouvÃ©es\n  }\n  let updatedContent = htmlContent;\n\n  // Traiter chaque image trouvÃ©e\n  for (const match of matches) {\n    const fullMatch = match[0];\n    const fileName = match[1];\n    const relativeUrl = `./assets/${fileName}`;\n\n    // Convertir en Blob URL\n    const blobUrl = await convertPromptoDysUrlToBlob(relativeUrl, documentDirectory);\n\n    // Remplacer dans le contenu si la conversion a rÃ©ussi\n    if (blobUrl !== relativeUrl) {\n      const updatedImg = fullMatch.replace(relativeUrl, blobUrl);\n      updatedContent = updatedContent.replace(fullMatch, updatedImg);\n    }\n  }\n  return updatedContent;\n};\n\n/**\n * VÃ©rifie si PromptoDYS est supportÃ©\n */\nexport const isPromptoDysSupported = () => {\n  return isFileSystemAccessSupported();\n};","map":{"version":3,"names":["isFileSystemAccessSupported","window","generateTimestampFolderName","now","Date","year","getFullYear","month","String","getMonth","padStart","day","getDate","hours","getHours","minutes","getMinutes","generateImageFileName","originalName","extension","timestamp","toString","getSeconds","baseName","replace","currentProjectDirectory","currentProjectName","setCurrentProject","documentHandle","documentName","localStorage","setItem","console","log","getCurrentProject","directory","name","getLastWorkspaceName","savedWorkspace","getItem","workspace","JSON","parse","error","initializePromptoDysWorkspace","skipDialog","Error","promptoDysHandle","showDirectoryPicker","mode","startIn","stringify","toISOString","createPromptoDysDocument","promptoDysDirectory","getDirectoryHandle","create","createOrGetPromptoDysDocument","saveImageToPromptoDys","imageFile","documentDirectory","assetsHandle","fileExtension","split","pop","toLowerCase","fileName","fileHandle","getFileHandle","writable","createWritable","write","close","relativePath","saveMarkdownToPromptoDys","content","mdFileName","endsWith","listPromptoDysDocuments","documents","handle","entries","kind","startsWith","hasMarkdown","push","displayName","sort","a","b","localeCompare","resetCurrentDocument","removeItem","isPromptoDysConnected","restorePromptoDysState","document","savedDocumentName","warn","ensureCurrentDocument","current","getPromptoDysWorkspace","convertPromptoDysUrlToBlob","relativeUrl","file","getFile","blobUrl","URL","createObjectURL","convertAllPromptoDysUrlsToBlobs","htmlContent","imageRegex","matches","matchAll","length","updatedContent","match","fullMatch","updatedImg","isPromptoDysSupported"],"sources":["C:/Users/JEAN-NOELLEFEBVRE-SA/CascadeProjects/editor/src/utils/promptoDysManager.js"],"sourcesContent":["/**\n * Gestionnaire pour le systÃ¨me de fichiers PromptoDYS\n * GÃ¨re l'organisation des documents et images dans une structure cohÃ©rente\n */\n\n/**\n * VÃ©rifie si la File System Access API est disponible\n */\nexport const isFileSystemAccessSupported = () => {\n  return typeof window !== 'undefined' && 'showDirectoryPicker' in window;\n};\n\n/**\n * GÃ©nÃ¨re un nom de dossier basÃ© sur un timestamp\n * Format: Document_YYYYMMDD_HHMM\n */\nexport const generateTimestampFolderName = () => {\n  const now = new Date();\n  const year = now.getFullYear();\n  const month = String(now.getMonth() + 1).padStart(2, '0');\n  const day = String(now.getDate()).padStart(2, '0');\n  const hours = String(now.getHours()).padStart(2, '0');\n  const minutes = String(now.getMinutes()).padStart(2, '0');\n  \n  return `Document_${year}${month}${day}_${hours}${minutes}`;\n};\n\n/**\n * GÃ©nÃ¨re un nom de fichier image unique avec timestamp\n */\nexport const generateImageFileName = (originalName, extension) => {\n  const now = new Date();\n  const timestamp = now.getFullYear().toString() + \n                   String(now.getMonth() + 1).padStart(2, '0') +\n                   String(now.getDate()).padStart(2, '0') + '_' +\n                   String(now.getHours()).padStart(2, '0') +\n                   String(now.getMinutes()).padStart(2, '0') +\n                   String(now.getSeconds()).padStart(2, '0');\n  \n  const baseName = originalName.replace(/\\.[^/.]+$/, \"\") || 'image';\n  return `${baseName}_${timestamp}.${extension}`;\n};\n\n/**\n * Ã‰tat global du rÃ©pertoire de travail actuel\n */\nlet currentProjectDirectory = null;\nlet currentProjectName = null;\n\n/**\n * DÃ©finit le document PromptoDYS actuel\n */\nexport const setCurrentProject = (documentHandle, documentName) => {\n  currentProjectDirectory = documentHandle;\n  currentProjectName = documentName;\n  \n  // Sauvegarder en localStorage pour persistance\n  if (documentName) {\n    localStorage.setItem('currentPromptoDysProject', documentName);\n    localStorage.setItem('promptoDysConnected', 'true');\n    console.log('ðŸ’¾ Document sauvÃ© en localStorage:', documentName);\n  }\n};\n\n/**\n * RÃ©cupÃ¨re le document PromptoDYS actuel\n */\nexport const getCurrentProject = () => {\n  return {\n    directory: currentProjectDirectory,\n    name: currentProjectName\n  };\n};\n\n/**\n * RÃ©cupÃ¨re le nom du dernier workspace PromptoDYS utilisÃ©\n */\nexport const getLastWorkspaceName = () => {\n  try {\n    const savedWorkspace = localStorage.getItem('promptoDysWorkspaceHandle');\n    if (savedWorkspace) {\n      const workspace = JSON.parse(savedWorkspace);\n      return workspace.name || null;\n    }\n  } catch (error) {\n    console.error('âŒ Erreur rÃ©cupÃ©ration nom workspace:', error);\n  }\n  return null;\n};\n\n/**\n * Initialise le workspace PromptoDYS\n * Demande Ã  l'utilisateur de sÃ©lectionner le dossier PromptoDYS\n */\nexport const initializePromptoDysWorkspace = async (skipDialog = false) => {\n  if (!isFileSystemAccessSupported()) {\n    throw new Error('File System Access API non supportÃ©e');\n  }\n\n  // Si skipDialog est true, essayer de restaurer le workspace existant\n  if (skipDialog) {\n    console.log('ðŸ” Tentative restauration workspace silencieuse...');\n    // Pour skipDialog, on ne peut pas demander de nouvelle sÃ©lection\n    // On retourne null pour signaler l'Ã©chec de restauration silencieuse\n    return null;\n  }\n\n  try {\n    // Demander Ã  l'utilisateur de sÃ©lectionner le dossier PromptoDYS\n    console.log('ðŸ—‚ï¸ SÃ©lection du dossier PromptoDYS...');\n    const promptoDysHandle = await window.showDirectoryPicker({\n      mode: 'readwrite',\n      startIn: 'documents'\n    });\n\n    // Sauvegarder la rÃ©fÃ©rence du workspace (sans crÃ©er de document)\n    localStorage.setItem('promptoDysWorkspaceHandle', JSON.stringify({\n      name: promptoDysHandle.name,\n      timestamp: new Date().toISOString()\n    }));\n\n    console.log('âœ… Workspace PromptoDYS configurÃ©:', promptoDysHandle.name);\n    return promptoDysHandle;\n  } catch (error) {\n    if (error.name === 'AbortError') {\n      throw new Error('SÃ©lection du dossier PromptoDYS annulÃ©e.');\n    } else {\n      console.error('âŒ Erreur initialisation PromptoDYS:', error);\n      throw error;\n    }\n  }\n};\n\n/**\n * CrÃ©e un nouveau document PromptoDYS avec un nom timestamp\n */\nexport const createPromptoDysDocument = async (promptoDysDirectory) => {\n  if (!promptoDysDirectory) {\n    // Tenter de rÃ©cupÃ©rer le workspace depuis initializePromptoDysWorkspace\n    try {\n      const workspace = await initializePromptoDysWorkspace();\n      promptoDysDirectory = workspace;\n    } catch (error) {\n      console.error('âŒ Impossible d\\'initialiser le workspace:', error);\n      return null;\n    }\n  }\n\n  try {\n    const documentName = generateTimestampFolderName();\n    \n    // CrÃ©er le dossier du document\n    const documentHandle = await promptoDysDirectory.getDirectoryHandle(documentName, {\n      create: true\n    });\n    \n    // CrÃ©er le dossier assets\n    await documentHandle.getDirectoryHandle('assets', {\n      create: true\n    });\n    \n    // DÃ©finir comme document actuel\n    setCurrentProject(documentHandle, documentName);\n    \n    console.log('âœ… Nouveau document PromptoDYS crÃ©Ã©:', documentName);\n    return documentHandle;\n  } catch (error) {\n    console.error('âŒ Erreur crÃ©ation document PromptoDYS:', error);\n    return null;\n  }\n};\n\n/**\n * CrÃ©e ou rÃ©cupÃ¨re un document PromptoDYS avec un nom personnalisÃ©\n */\nexport const createOrGetPromptoDysDocument = async (promptoDysDirectory, documentName) => {\n  if (!promptoDysDirectory) {\n    // Tenter de rÃ©cupÃ©rer le workspace depuis initializePromptoDysWorkspace\n    try {\n      const workspace = await initializePromptoDysWorkspace();\n      promptoDysDirectory = workspace;\n    } catch (error) {\n      console.error('âŒ Impossible d\\'initialiser le workspace:', error);\n      return null;\n    }\n  }\n\n  try {\n    // CrÃ©er ou rÃ©cupÃ©rer le dossier du document\n    const documentHandle = await promptoDysDirectory.getDirectoryHandle(documentName, {\n      create: true\n    });\n    \n    // CrÃ©er le dossier assets s'il n'existe pas\n    await documentHandle.getDirectoryHandle('assets', {\n      create: true\n    });\n    \n    // DÃ©finir comme document actuel\n    setCurrentProject(documentHandle, documentName);\n    \n    console.log('âœ… Document PromptoDYS configurÃ©:', documentName);\n    return documentHandle;\n  } catch (error) {\n    console.error('âŒ Erreur configuration document PromptoDYS:', error);\n    return null;\n  }\n};\n\n/**\n * Sauvegarde une image dans le dossier assets du document actuel\n */\nexport const saveImageToPromptoDys = async (imageFile, documentDirectory) => {\n  if (!documentDirectory) return null;\n\n  try {\n    // Obtenir le dossier assets\n    const assetsHandle = await documentDirectory.getDirectoryHandle('assets', {\n      create: true\n    });\n    \n    // GÃ©nÃ©rer un nom de fichier unique\n    const fileExtension = imageFile.name.split('.').pop().toLowerCase();\n    const fileName = generateImageFileName(imageFile.name, fileExtension);\n    \n    // CrÃ©er le fichier image\n    const fileHandle = await assetsHandle.getFileHandle(fileName, {\n      create: true\n    });\n    \n    // Ã‰crire les donnÃ©es\n    const writable = await fileHandle.createWritable();\n    await writable.write(imageFile);\n    await writable.close();\n    \n    console.log('âœ… Image sauvegardÃ©e:', fileName);\n    \n    // Retourner le chemin relatif pour Markdown\n    const relativePath = `./assets/${fileName}`;\n    \n    console.log('ðŸ“ Image sauvÃ©e avec chemin relatif:', relativePath);\n    return relativePath;\n  } catch (error) {\n    console.error('âŒ Erreur sauvegarde image:', error);\n    return null;\n  }\n};\n\n/**\n * Sauvegarde le fichier Markdown dans le document PromptoDYS\n */\nexport const saveMarkdownToPromptoDys = async (content, documentDirectory, fileName) => {\n  if (!documentDirectory) return false;\n\n  try {\n    const mdFileName = fileName.endsWith('.md') ? fileName : `${fileName}.md`;\n    \n    const fileHandle = await documentDirectory.getFileHandle(mdFileName, {\n      create: true\n    });\n    \n    const writable = await fileHandle.createWritable();\n    await writable.write(content);\n    await writable.close();\n    \n    console.log('âœ… Fichier Markdown sauvegardÃ©:', mdFileName);\n    return true;\n  } catch (error) {\n    console.error('âŒ Erreur sauvegarde Markdown:', error);\n    return false;\n  }\n};\n\n/**\n * Liste les documents PromptoDYS disponibles\n */\nexport const listPromptoDysDocuments = async (promptoDysDirectory) => {\n  if (!promptoDysDirectory) return [];\n\n  try {\n    const documents = [];\n    \n    for await (const [name, handle] of promptoDysDirectory.entries()) {\n      if (handle.kind === 'directory' && name.startsWith('Document_')) {\n        // VÃ©rifier s'il y a un fichier .md dans le dossier\n        try {\n          let hasMarkdown = false;\n          for await (const [fileName, fileHandle] of handle.entries()) {\n            if (fileHandle.kind === 'file' && fileName.endsWith('.md')) {\n              hasMarkdown = true;\n              break;\n            }\n          }\n          \n          if (hasMarkdown) {\n            documents.push({\n              name,\n              handle,\n              displayName: name.replace('Document_', '').replace(/_/g, '/')\n            });\n          }\n        } catch (error) {\n          // Ignorer les dossiers inaccessibles\n        }\n      }\n    }\n    \n    // Trier par nom (plus rÃ©cent en premier)\n    return documents.sort((a, b) => b.name.localeCompare(a.name));\n  } catch (error) {\n    console.error('âŒ Erreur liste documents:', error);\n    return [];\n  }\n};\n\n/**\n * RÃ©initialise le document actuel (pour nouveau document)\n */\nexport const resetCurrentDocument = () => {\n  currentProjectDirectory = null;\n  currentProjectName = null;\n  localStorage.removeItem('currentPromptoDysProject');\n  localStorage.removeItem('promptoDysConnected');\n  console.log('ðŸ”„ Document PromptoDYS rÃ©initialisÃ©');\n};\n\n/**\n * VÃ©rifie si PromptoDYS Ã©tait connectÃ© prÃ©cÃ©demment\n */\nexport const isPromptoDysConnected = () => {\n  return localStorage.getItem('promptoDysConnected') === 'true';\n};\n\n/**\n * Tente de restaurer le workspace et document depuis localStorage\n */\nexport const restorePromptoDysState = async () => {\n  if (!isPromptoDysConnected()) {\n    return { workspace: null, document: null };\n  }\n\n  try {\n    // Restaurer le workspace\n    const workspace = await initializePromptoDysWorkspace();\n    if (!workspace) {\n      return { workspace: null, document: null };\n    }\n\n    // Restaurer le document actuel\n    const savedDocumentName = localStorage.getItem('currentPromptoDysProject');\n    if (savedDocumentName) {\n      try {\n        const documentHandle = await workspace.getDirectoryHandle(savedDocumentName);\n        setCurrentProject(documentHandle, savedDocumentName);\n        console.log('âœ… Document PromptoDYS restaurÃ©:', savedDocumentName);\n        return { workspace, document: documentHandle };\n      } catch (error) {\n        console.warn('âš ï¸ Document sauvÃ© introuvable, en crÃ©er un nouveau:', savedDocumentName);\n      }\n    }\n\n    return { workspace, document: null };\n  } catch (error) {\n    console.error('âŒ Erreur restauration PromptoDYS:', error);\n    // Nettoyer localStorage si restauration Ã©choue\n    localStorage.removeItem('promptoDysConnected');\n    localStorage.removeItem('currentPromptoDysProject');\n    return { workspace: null, document: null };\n  }\n};\n\n/**\n * CrÃ©e automatiquement un document aprÃ¨s connexion workspace\n */\nexport const ensureCurrentDocument = async (workspace) => {\n  if (!workspace) return null;\n  \n  // VÃ©rifier si on a dÃ©jÃ  un document actuel\n  const current = getCurrentProject();\n  if (current.directory) {\n    return current.directory;\n  }\n\n  // CrÃ©er un nouveau document\n  return await createPromptoDysDocument(workspace);\n};\n\n/**\n * Obtient une rÃ©fÃ©rence au workspace PromptoDYS principal\n */\nexport const getPromptoDysWorkspace = async () => {\n  try {\n    return await initializePromptoDysWorkspace();\n  } catch (error) {\n    console.error('âŒ Impossible d\\'obtenir le workspace PromptoDYS:', error);\n    return null;\n  }\n};\n\n/**\n * Convertit une URL relative PromptoDYS en Blob URL pour affichage\n */\nexport const convertPromptoDysUrlToBlob = async (relativeUrl, documentDirectory) => {\n  if (!relativeUrl || !documentDirectory || !relativeUrl.startsWith('./assets/')) {\n    return relativeUrl; // Retourner l'URL originale si pas une URL PromptoDYS\n  }\n\n  try {\n    // Extraire le nom de fichier depuis l'URL relative\n    const fileName = relativeUrl.replace('./assets/', '');\n    \n    // AccÃ©der au dossier assets\n    const assetsHandle = await documentDirectory.getDirectoryHandle('assets');\n    \n    // RÃ©cupÃ©rer le fichier\n    const fileHandle = await assetsHandle.getFileHandle(fileName);\n    const file = await fileHandle.getFile();\n    \n    // CrÃ©er une Blob URL temporaire\n    const blobUrl = URL.createObjectURL(file);\n    \n    console.log(`âœ… Blob URL crÃ©Ã©e: ${fileName} -> ${blobUrl}`);\n    return blobUrl;\n  } catch (error) {\n    console.error(`âŒ Erreur conversion Blob URL pour ${relativeUrl}:`, error);\n    return relativeUrl; // Fallback sur l'URL originale\n  }\n};\n\n/**\n * Convertit toutes les URLs relatives PromptoDYS en Blob URLs dans un contenu HTML\n */\nexport const convertAllPromptoDysUrlsToBlobs = async (htmlContent, documentDirectory) => {\n  if (!htmlContent || !documentDirectory) {\n    return htmlContent;\n  }\n\n  // Regex pour trouver toutes les URLs d'images PromptoDYS\n  const imageRegex = /<img[^>]+src=[\"']\\.\\/assets\\/([^\"']+)[\"'][^>]*>/g;\n  const matches = [...htmlContent.matchAll(imageRegex)];\n  \n  if (matches.length === 0) {\n    return htmlContent; // Pas d'images PromptoDYS trouvÃ©es\n  }\n\n  let updatedContent = htmlContent;\n  \n  // Traiter chaque image trouvÃ©e\n  for (const match of matches) {\n    const fullMatch = match[0];\n    const fileName = match[1];\n    const relativeUrl = `./assets/${fileName}`;\n    \n    // Convertir en Blob URL\n    const blobUrl = await convertPromptoDysUrlToBlob(relativeUrl, documentDirectory);\n    \n    // Remplacer dans le contenu si la conversion a rÃ©ussi\n    if (blobUrl !== relativeUrl) {\n      const updatedImg = fullMatch.replace(relativeUrl, blobUrl);\n      updatedContent = updatedContent.replace(fullMatch, updatedImg);\n    }\n  }\n  \n  return updatedContent;\n};\n\n/**\n * VÃ©rifie si PromptoDYS est supportÃ©\n */\nexport const isPromptoDysSupported = () => {\n  return isFileSystemAccessSupported();\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}