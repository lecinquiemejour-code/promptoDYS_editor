{"ast":null,"code":"// Convertisseur HTML ↔ Markdown pour l'éditeur\n/**\n * Convertit du HTML en Markdown\n * @param {string} html - Le contenu HTML à convertir\n * @returns {string} - Le contenu Markdown\n */export const htmlToMarkdown=html=>{if(!html)return'';// Fonction pour normaliser les couleurs RGB vers hex\nconst rgbToHex=rgb=>{const match=rgb.match(/rgb\\((\\d+),\\s*(\\d+),\\s*(\\d+)\\)/);if(!match)return rgb;const r=parseInt(match[1]);const g=parseInt(match[2]);const b=parseInt(match[3]);return\"#\".concat(((1<<24)+(r<<16)+(g<<8)+b).toString(16).slice(1));};// Préserver les spans colorés en les marquant temporairement ET normaliser les couleurs\nconst colorSpanMarkers=[];let tempHtml=html.replace(/<span[^>]*style=\"[^\"]*color:[^\"]*\"[^>]*>[^]*?<\\/span>/gi,match=>{// Normaliser rgb() vers hex dans le span\nconst normalizedMatch=match.replace(/color:\\s*rgb\\([^)]+\\)/gi,colorMatch=>{const hexColor=rgbToHex(colorMatch.replace('color:','').trim());return\"color: \".concat(hexColor);});const marker=\"__COLOR_SPAN_\".concat(colorSpanMarkers.length,\"__\");colorSpanMarkers.push(normalizedMatch);return marker;});let markdown=tempHtml// Décoder les entités HTML AVANT tout traitement\n.replace(/&amp;/g,'&').replace(/&lt;/g,'<').replace(/&gt;/g,'>').replace(/&quot;/g,'\"').replace(/&#39;/g,\"'\")// Nettoyer le HTML d'abord\n.replace(/\\n\\s*\\n/g,'\\n')// Supprimer les lignes vides multiples\n.replace(/^\\s+|\\s+$/g,'')// Trim\n// Titres H1-H6\n.replace(/<h1[^>]*>(.*?)<\\/h1>/gi,'# $1\\n').replace(/<h2[^>]*>(.*?)<\\/h2>/gi,'## $1\\n').replace(/<h3[^>]*>(.*?)<\\/h3>/gi,'### $1\\n').replace(/<h4[^>]*>(.*?)<\\/h4>/gi,'#### $1\\n').replace(/<h5[^>]*>(.*?)<\\/h5>/gi,'##### $1\\n').replace(/<h6[^>]*>(.*?)<\\/h6>/gi,'###### $1\\n')// Images - préserver width et height comme attributs HTML\n.replace(/<img[^>]*src=\"([^\"]*)\"[^>]*alt=\"([^\"]*)\"[^>]*(width=\"[^\"]*\"|height=\"[^\"]*\")[^>]*\\/?>/gi,(match,src,alt)=>{const widthMatch=match.match(/width=\"([^\"]*)\"/i);const heightMatch=match.match(/height=\"([^\"]*)\"/i);let result=\"![\".concat(alt,\"](\").concat(src,\")\");if(widthMatch||heightMatch){result+='{';if(widthMatch)result+=\"width=\".concat(widthMatch[1]);if(widthMatch&&heightMatch)result+=' ';if(heightMatch)result+=\"height=\".concat(heightMatch[1]);result+='}';}return result;}).replace(/<img[^>]*alt=\"([^\"]*)\"[^>]*src=\"([^\"]*)\"[^>]*(width=\"[^\"]*\"|height=\"[^\"]*\")[^>]*\\/?>/gi,(match,alt,src)=>{const widthMatch=match.match(/width=\"([^\"]*)\"/i);const heightMatch=match.match(/height=\"([^\"]*)\"/i);let result=\"![\".concat(alt,\"](\").concat(src,\")\");if(widthMatch||heightMatch){result+='{';if(widthMatch)result+=\"width=\".concat(widthMatch[1]);if(widthMatch&&heightMatch)result+=' ';if(heightMatch)result+=\"height=\".concat(heightMatch[1]);result+='}';}return result;}).replace(/<img[^>]*src=\"([^\"]*)\"[^>]*(width=\"[^\"]*\"|height=\"[^\"]*\")[^>]*\\/?>/gi,(match,src)=>{const widthMatch=match.match(/width=\"([^\"]*)\"/i);const heightMatch=match.match(/height=\"([^\"]*)\"/i);let result=\"![](\".concat(src,\")\");if(widthMatch||heightMatch){result+='{';if(widthMatch)result+=\"width=\".concat(widthMatch[1]);if(widthMatch&&heightMatch)result+=' ';if(heightMatch)result+=\"height=\".concat(heightMatch[1]);result+='}';}return result;})// Images sans dimensions (fallback)\n.replace(/<img[^>]*src=\"([^\"]*)\"[^>]*alt=\"([^\"]*)\"[^>]*\\/?>/gi,'![$2]($1)').replace(/<img[^>]*alt=\"([^\"]*)\"[^>]*src=\"([^\"]*)\"[^>]*\\/?>/gi,'![$1]($2)').replace(/<img[^>]*src=\"([^\"]*)\"[^>]*\\/?>/gi,'![]($1)')// Formatage gras et italique\n.replace(/<strong[^>]*>(.*?)<\\/strong>/gi,'**$1**').replace(/<b[^>]*>(.*?)<\\/b>/gi,'**$1**').replace(/<em[^>]*>(.*?)<\\/em>/gi,'*$1*').replace(/<i[^>]*>(.*?)<\\/i>/gi,'*$1*')// Paragraphes - vrais blocs avec double saut de ligne\n.replace(/<p[^>]*>(.*?)<\\/p>/gi,(match,content)=>{const trimmed=content.trim();return trimmed?\"\".concat(trimmed,\"\\n\\n\"):'';})// Divs génériques - lignes simples\n.replace(/<div[^>]*>(.*?)<\\/div>/gi,'$1\\n')// Sauts de ligne\n.replace(/<br\\s*\\/?>/gi,'\\n')// Traiter les listes dans l'ordre de priorité : OL alphabétiques -> OL numériques -> UL puces\n// 1. Listes alphabétiques (OL avec style lower-alpha) - DÉTECTION AMÉLIORÉE\n.replace(/<ol[^>]*(?:style=\"[^\"]*list-style-type:\\s*lower-alpha[^\"]*\"|style=\"[^\"]*lower-alpha[^\"]*\")[^>]*>([^]*?)<\\/ol>/gi,(match,content)=>{const items=content.match(/<li[^>]*>([^]*?)<\\/li>/gi)||[];const startMatch=match.match(/start=\"(\\d+)\"/);const startIndex=startMatch?parseInt(startMatch[1])-1:0;return items.map((item,index)=>{const text=item.replace(/<li[^>]*>([^]*?)<\\/li>/gi,'$1').trim();const letter=String.fromCharCode(97+startIndex+index);return\"\".concat(letter,\". \").concat(text);}).join('\\n')+'\\n';})// 2. Listes numérotées (OL sans style lower-alpha) - REGEX RENFORCÉE\n.replace(/<ol(?![^>]*(?:style=\"[^\"]*list-style-type:\\s*lower-alpha|style=\"[^\"]*lower-alpha))[^>]*>([^]*?)<\\/ol>/gi,(match,content)=>{const items=content.match(/<li[^>]*>([^]*?)<\\/li>/gi)||[];const startMatch=match.match(/start=\"(\\d+)\"/);const startNumber=startMatch?parseInt(startMatch[1]):1;return items.map((item,index)=>{const text=item.replace(/<li[^>]*>([^]*?)<\\/li>/gi,'$1').trim();return\"\".concat(startNumber+index,\". \").concat(text);}).join('\\n')+'\\n';})// 3. Listes à puces (UL) - NETTOYAGE DES BALISES INTERNES\n.replace(/<ul[^>]*>([^]*?)<\\/ul>/gi,(match,content)=>{const items=content.match(/<li[^>]*>([^]*?)<\\/li>/gi)||[];return items.map(item=>{const text=item.replace(/<li[^>]*>([^]*?)<\\/li>/gi,'$1').replace(/<[^>]+>/g,'')// Supprimer toutes les balises internes\n.trim();return\"- \".concat(text);}).join('\\n')+'\\n';})// Restaurer les spans colorés\n.replace(/__COLOR_SPAN_(\\d+)__/g,(match,index)=>{return colorSpanMarkers[parseInt(index)]||'';})// Supprimer toutes les autres balises HTML SAUF les spans colorés\n.replace(/<(?!span\\s+style=\"[^\"]*color:|\\/span>)[^>]+>/gi,'')// Nettoyer les espaces multiples\n.replace(/[ \\t]+/g,' ').replace(/\\n[ \\t]+/g,'\\n')// Normaliser les sauts de ligne sans détruire la structure\n.replace(/\\n{3,}/g,'\\n\\n')// Maximum 2 sauts consécutifs\n.trim();return markdown;};/**\n * Convertit du Markdown en HTML\n * @param {string} markdown - Le contenu Markdown à convertir\n * @returns {string} - Le contenu HTML\n */export const markdownToHtml=markdown=>{if(!markdown)return'';// Préserver les spans HTML existants dans le Markdown\nconst spanMarkers=[];let tempMarkdown=markdown.replace(/<span[^>]*style=\"[^\"]*color:[^\"]*\"[^>]*>[^]*?<\\/span>/gi,match=>{const marker=\"__SPAN_PRESERVE_\".concat(spanMarkers.length,\"__\");spanMarkers.push(match);return marker;});let html=tempMarkdown// Échapper les caractères HTML spéciaux SAUF pour les spans préservés\n.replace(/&(?!__SPAN_PRESERVE_)/g,'&amp;').replace(/<(?!__SPAN_PRESERVE_)/g,'&lt;').replace(/>(?!__SPAN_PRESERVE_)/g,'&gt;')// Titres H1-H6\n.replace(/^#{6}\\s+(.+)$/gm,'<h6>$1</h6>').replace(/^#{5}\\s+(.+)$/gm,'<h5>$1</h5>').replace(/^#{4}\\s+(.+)$/gm,'<h4>$1</h4>').replace(/^#{3}\\s+(.+)$/gm,'<h3>$1</h3>').replace(/^#{2}\\s+(.+)$/gm,'<h2>$1</h2>').replace(/^#{1}\\s+(.+)$/gm,'<h1>$1</h1>')// Images - traiter AVANT les autres conversions pour éviter les conflits\n.replace(/!\\[([^\\]]*)\\]\\(([^)]+)\\)\\{([^}]+)\\}/g,(match,alt,src,dimensions)=>{let imgTag=\"<img src=\\\"\".concat(src,\"\\\" alt=\\\"\").concat(alt,\"\\\"\");// Parser les dimensions width=X height=Y\nconst widthMatch=dimensions.match(/width=([\\w%]+)/);const heightMatch=dimensions.match(/height=([\\w%]+)/);if(widthMatch){imgTag+=\" width=\\\"\".concat(widthMatch[1],\"\\\"\");}if(heightMatch){imgTag+=\" height=\\\"\".concat(heightMatch[1],\"\\\"\");}imgTag+=' style=\"max-width: 100%; height: auto; margin: 0.5em 0;\" />';return imgTag;})// Images sans dimensions (fallback)\n.replace(/!\\[([^\\]]*)\\]\\(([^)]+)\\)/g,'<img src=\"$2\" alt=\"$1\" style=\"max-width: 100%; height: auto; margin: 0.5em 0;\" />')// Formatage gras et italique\n.replace(/\\*\\*([^*]+)\\*\\*/g,'<strong>$1</strong>').replace(/\\*([^*]+)\\*/g,'<em>$1</em>')// TRAITER LES LISTES AVANT LA CONVERSION \\n -> <br>\n// Listes à puces\n.replace(/^(\\s*)-\\s+(.+)$/gm,'<li data-type=\"bullet\">$2</li>')// Listes numérotées - préserver le numéro original\n.replace(/^(\\s*)(\\d+)\\.\\s+(.+)$/gm,'<li data-type=\"number\" data-number=\"$2\">$3</li>')// Listes alphabétiques - préserver la lettre originale\n.replace(/^(\\s*)([a-z])\\.\\s+(.+)$/gm,'<li data-type=\"letter\" data-letter=\"$2\">$3</li>')// Regrouper les éléments de liste consécutifs PAR TYPE HOMOGÈNE\n.replace(/(<li[^>]*data-type=\"[^\"]*\"[^>]*>[^]*?<\\/li>\\n?)+/g,match=>{const items=match.match(/<li[^>]*data-type=\"[^\"]*\"[^>]*>[^]*?<\\/li>/g)||[];const groups=[];let currentGroup=[];let currentType=null;// Séparer par type homogène\nfor(const item of items){const typeMatch=item.match(/data-type=\"([^\"]*)\"/);const itemType=typeMatch?typeMatch[1]:null;if(itemType!==currentType){// Nouveau type détecté - finaliser le groupe précédent\nif(currentGroup.length>0){groups.push({type:currentType,items:currentGroup});}currentGroup=[item];currentType=itemType;}else{// Même type - ajouter au groupe actuel\ncurrentGroup.push(item);}}// Finaliser le dernier groupe\nif(currentGroup.length>0){groups.push({type:currentType,items:currentGroup});}// Convertir chaque groupe en HTML approprié\nreturn groups.map(group=>{const{type,items}=group;if(type==='letter'){// Listes alphabétiques\nconst firstLetterMatch=items[0].match(/data-letter=\"([a-z])\"/);const startLetter=firstLetterMatch?firstLetterMatch[1]:'a';const startIndex=startLetter.charCodeAt(0)-97;// a=0, b=1, c=2...\nconst cleanItems=items.map(item=>item.replace(/ data-type=\"[^\"]*\"| data-letter=\"[^\"]*\"/g,''));if(startIndex>0){return\"<ol style=\\\"list-style-type: lower-alpha;\\\" start=\\\"\".concat(startIndex+1,\"\\\">\").concat(cleanItems.join(''),\"</ol>\");}else{return\"<ol style=\\\"list-style-type: lower-alpha;\\\">\".concat(cleanItems.join(''),\"</ol>\");}}else if(type==='number'){// Listes numérotées\nconst firstNumberMatch=items[0].match(/data-number=\"(\\d+)\"/);const startNumber=firstNumberMatch?parseInt(firstNumberMatch[1]):1;const cleanItems=items.map(item=>item.replace(/ data-type=\"[^\"]*\"| data-number=\"[^\"]*\"/g,''));if(startNumber>1){return\"<ol start=\\\"\".concat(startNumber,\"\\\">\").concat(cleanItems.join(''),\"</ol>\");}else{return\"<ol>\".concat(cleanItems.join(''),\"</ol>\");}}else if(type==='bullet'){// Listes à puces\nconst cleanItems=items.map(item=>item.replace(/ data-type=\"[^\"]*\"/g,''));return\"<ul>\".concat(cleanItems.join(''),\"</ul>\");}else{// Type inconnu - retourner tel quel\nreturn items.join('');}}).join('\\n')+'\\n';})// Traiter les paragraphes par blocs séparés par double saut AVANT conversion \\n → <br>\n.split('\\n\\n').map(block=>{block=block.trim();if(!block)return'';// Si c'est déjà du HTML (titres, listes), le garder tel quel SANS conversion \\n → <br>\nif(block.match(/^<h[1-6]|<ul|<ol/))return block;// Si le bloc contient des listes, ne pas l'envelopper dans des divs\nif(block.match(/<ul|<ol/))return block;// Pour les autres blocs, convertir \\n → <br> puis traiter\nconst processedBlock=block.replace(/\\n(?!\\n)(?!$)/g,'<br>');const lines=processedBlock.split('<br>').map(line=>line.trim()).filter(line=>line);if(lines.length===1){// Une seule ligne → <div> (ligne simple)\nreturn\"<div>\".concat(lines[0],\"</div>\");}else{// Plusieurs lignes → <div> avec <br> pour préserver les sauts\nreturn\"<div>\".concat(lines.join('<br>'),\"</div>\");}}).filter(block=>block).join('\\n')// Restaurer les spans colorés préservés\n.replace(/__SPAN_PRESERVE_(\\d+)__/g,(match,index)=>{return spanMarkers[parseInt(index)]||'';})// Nettoyer les <br> et espaces indésirables après les balises de bloc\n.replace(/(<\\/(?:ul|ol|h[1-6])>)\\s*<br>/g,'$1').replace(/(<\\/(?:ul|ol|h[1-6])>)\\s*\\n/g,'$1')// Nettoyer les lignes vides multiples\n.replace(/\\n{2,}/g,'\\n').replace(/^\\n+|\\n+$/g,'');return html;};/**\n * Détecte si le contenu contient de la syntaxe Markdown\n * @param {string} content - Le contenu à analyser\n * @returns {boolean} - true si c'est du Markdown\n */export const isMarkdownContent=content=>{if(!content)return false;const markdownPatterns=[/^#{1,6}\\s+/m,// Titres\n/\\*\\*[^*]+\\*\\*/,// Gras\n/\\*[^*]+\\*/,// Italique\n/^[-*]\\s+/m,// Listes à puces\n/^\\d+\\.\\s+/m,// Listes numérotées\n/^[a-z]\\.\\s+/m,// Listes alphabétiques\n/!\\[.*?\\]\\([^)]+\\)/// Images\n];return markdownPatterns.some(pattern=>pattern.test(content));};","map":{"version":3,"names":["htmlToMarkdown","html","rgbToHex","rgb","match","r","parseInt","g","b","concat","toString","slice","colorSpanMarkers","tempHtml","replace","normalizedMatch","colorMatch","hexColor","trim","marker","length","push","markdown","src","alt","widthMatch","heightMatch","result","content","trimmed","items","startMatch","startIndex","map","item","index","text","letter","String","fromCharCode","join","startNumber","markdownToHtml","spanMarkers","tempMarkdown","dimensions","imgTag","groups","currentGroup","currentType","typeMatch","itemType","type","group","firstLetterMatch","startLetter","charCodeAt","cleanItems","firstNumberMatch","split","block","processedBlock","lines","line","filter","isMarkdownContent","markdownPatterns","some","pattern","test"],"sources":["C:/Users/JEAN-NOELLEFEBVRE-SA/CascadeProjects/editor/src/utils/markdownConverter.js"],"sourcesContent":["// Convertisseur HTML ↔ Markdown pour l'éditeur\n\n/**\n * Convertit du HTML en Markdown\n * @param {string} html - Le contenu HTML à convertir\n * @returns {string} - Le contenu Markdown\n */\nexport const htmlToMarkdown = (html) => {\n  if (!html) return '';\n  \n  // Fonction pour normaliser les couleurs RGB vers hex\n  const rgbToHex = (rgb) => {\n    const match = rgb.match(/rgb\\((\\d+),\\s*(\\d+),\\s*(\\d+)\\)/);\n    if (!match) return rgb;\n    \n    const r = parseInt(match[1]);\n    const g = parseInt(match[2]);\n    const b = parseInt(match[3]);\n    \n    return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`;\n  };\n\n  // Préserver les spans colorés en les marquant temporairement ET normaliser les couleurs\n  const colorSpanMarkers = [];\n  let tempHtml = html.replace(/<span[^>]*style=\"[^\"]*color:[^\"]*\"[^>]*>.*?<\\/span>/gis, (match) => {\n    // Normaliser rgb() vers hex dans le span\n    const normalizedMatch = match.replace(/color:\\s*rgb\\([^)]+\\)/gi, (colorMatch) => {\n      const hexColor = rgbToHex(colorMatch.replace('color:', '').trim());\n      return `color: ${hexColor}`;\n    });\n    \n    const marker = `__COLOR_SPAN_${colorSpanMarkers.length}__`;\n    colorSpanMarkers.push(normalizedMatch);\n    return marker;\n  });\n  \n  let markdown = tempHtml\n    // Décoder les entités HTML AVANT tout traitement\n    .replace(/&amp;/g, '&')\n    .replace(/&lt;/g, '<')\n    .replace(/&gt;/g, '>')\n    .replace(/&quot;/g, '\"')\n    .replace(/&#39;/g, \"'\")\n  \n    // Nettoyer le HTML d'abord\n    .replace(/\\n\\s*\\n/g, '\\n') // Supprimer les lignes vides multiples\n    .replace(/^\\s+|\\s+$/g, '') // Trim\n    \n    // Titres H1-H6\n    .replace(/<h1[^>]*>(.*?)<\\/h1>/gi, '# $1\\n')\n    .replace(/<h2[^>]*>(.*?)<\\/h2>/gi, '## $1\\n')\n    .replace(/<h3[^>]*>(.*?)<\\/h3>/gi, '### $1\\n')\n    .replace(/<h4[^>]*>(.*?)<\\/h4>/gi, '#### $1\\n')\n    .replace(/<h5[^>]*>(.*?)<\\/h5>/gi, '##### $1\\n')\n    .replace(/<h6[^>]*>(.*?)<\\/h6>/gi, '###### $1\\n')\n    \n    // Images - préserver width et height comme attributs HTML\n    .replace(/<img[^>]*src=\"([^\"]*)\"[^>]*alt=\"([^\"]*)\"[^>]*(width=\"[^\"]*\"|height=\"[^\"]*\")[^>]*\\/?>/gi, (match, src, alt) => {\n      const widthMatch = match.match(/width=\"([^\"]*)\"/i);\n      const heightMatch = match.match(/height=\"([^\"]*)\"/i);\n      let result = `![${alt}](${src})`;\n      if (widthMatch || heightMatch) {\n        result += '{'\n        if (widthMatch) result += `width=${widthMatch[1]}`;\n        if (widthMatch && heightMatch) result += ' ';\n        if (heightMatch) result += `height=${heightMatch[1]}`;\n        result += '}';\n      }\n      return result;\n    })\n    .replace(/<img[^>]*alt=\"([^\"]*)\"[^>]*src=\"([^\"]*)\"[^>]*(width=\"[^\"]*\"|height=\"[^\"]*\")[^>]*\\/?>/gi, (match, alt, src) => {\n      const widthMatch = match.match(/width=\"([^\"]*)\"/i);\n      const heightMatch = match.match(/height=\"([^\"]*)\"/i);\n      let result = `![${alt}](${src})`;\n      if (widthMatch || heightMatch) {\n        result += '{'\n        if (widthMatch) result += `width=${widthMatch[1]}`;\n        if (widthMatch && heightMatch) result += ' ';\n        if (heightMatch) result += `height=${heightMatch[1]}`;\n        result += '}';\n      }\n      return result;\n    })\n    .replace(/<img[^>]*src=\"([^\"]*)\"[^>]*(width=\"[^\"]*\"|height=\"[^\"]*\")[^>]*\\/?>/gi, (match, src) => {\n      const widthMatch = match.match(/width=\"([^\"]*)\"/i);\n      const heightMatch = match.match(/height=\"([^\"]*)\"/i);\n      let result = `![](${src})`;\n      if (widthMatch || heightMatch) {\n        result += '{'\n        if (widthMatch) result += `width=${widthMatch[1]}`;\n        if (widthMatch && heightMatch) result += ' ';\n        if (heightMatch) result += `height=${heightMatch[1]}`;\n        result += '}';\n      }\n      return result;\n    })\n    // Images sans dimensions (fallback)\n    .replace(/<img[^>]*src=\"([^\"]*)\"[^>]*alt=\"([^\"]*)\"[^>]*\\/?>/gi, '![$2]($1)')\n    .replace(/<img[^>]*alt=\"([^\"]*)\"[^>]*src=\"([^\"]*)\"[^>]*\\/?>/gi, '![$1]($2)')\n    .replace(/<img[^>]*src=\"([^\"]*)\"[^>]*\\/?>/gi, '![]($1)')\n    \n    // Formatage gras et italique\n    .replace(/<strong[^>]*>(.*?)<\\/strong>/gi, '**$1**')\n    .replace(/<b[^>]*>(.*?)<\\/b>/gi, '**$1**')\n    .replace(/<em[^>]*>(.*?)<\\/em>/gi, '*$1*')\n    .replace(/<i[^>]*>(.*?)<\\/i>/gi, '*$1*')\n    \n    // Paragraphes - vrais blocs avec double saut de ligne\n    .replace(/<p[^>]*>(.*?)<\\/p>/gi, (match, content) => {\n      const trimmed = content.trim();\n      return trimmed ? `${trimmed}\\n\\n` : '';\n    })\n    \n    // Divs génériques - lignes simples\n    .replace(/<div[^>]*>(.*?)<\\/div>/gi, '$1\\n')\n    \n    // Sauts de ligne\n    .replace(/<br\\s*\\/?>/gi, '\\n')\n    \n    // Traiter les listes dans l'ordre de priorité : OL alphabétiques -> OL numériques -> UL puces\n    \n    // 1. Listes alphabétiques (OL avec style lower-alpha) - DÉTECTION AMÉLIORÉE\n    .replace(/<ol[^>]*(?:style=\"[^\"]*list-style-type:\\s*lower-alpha[^\"]*\"|style=\"[^\"]*lower-alpha[^\"]*\")[^>]*>(.*?)<\\/ol>/gis, (match, content) => {\n      const items = content.match(/<li[^>]*>(.*?)<\\/li>/gis) || [];\n      const startMatch = match.match(/start=\"(\\d+)\"/); \n      const startIndex = startMatch ? parseInt(startMatch[1]) - 1 : 0;\n      \n      return items.map((item, index) => {\n        const text = item.replace(/<li[^>]*>(.*?)<\\/li>/gis, '$1').trim();\n        const letter = String.fromCharCode(97 + startIndex + index);\n        return `${letter}. ${text}`;\n      }).join('\\n') + '\\n';\n    })\n    \n    // 2. Listes numérotées (OL sans style lower-alpha) - REGEX RENFORCÉE\n    .replace(/<ol(?![^>]*(?:style=\"[^\"]*list-style-type:\\s*lower-alpha|style=\"[^\"]*lower-alpha))[^>]*>(.*?)<\\/ol>/gis, (match, content) => {\n      const items = content.match(/<li[^>]*>(.*?)<\\/li>/gis) || [];\n      const startMatch = match.match(/start=\"(\\d+)\"/); \n      const startNumber = startMatch ? parseInt(startMatch[1]) : 1;\n      \n      return items.map((item, index) => {\n        const text = item.replace(/<li[^>]*>(.*?)<\\/li>/gis, '$1').trim();\n        return `${startNumber + index}. ${text}`;\n      }).join('\\n') + '\\n';\n    })\n    \n    // 3. Listes à puces (UL) - NETTOYAGE DES BALISES INTERNES\n    .replace(/<ul[^>]*>(.*?)<\\/ul>/gis, (match, content) => {\n      const items = content.match(/<li[^>]*>(.*?)<\\/li>/gis) || [];\n      return items.map(item => {\n        const text = item.replace(/<li[^>]*>(.*?)<\\/li>/gis, '$1')\n          .replace(/<[^>]+>/g, '') // Supprimer toutes les balises internes\n          .trim();\n        return `- ${text}`;\n      }).join('\\n') + '\\n';\n    })\n    \n    // Restaurer les spans colorés\n    .replace(/__COLOR_SPAN_(\\d+)__/g, (match, index) => {\n      return colorSpanMarkers[parseInt(index)] || '';\n    })\n    \n    // Supprimer toutes les autres balises HTML SAUF les spans colorés\n    .replace(/<(?!span\\s+style=\"[^\"]*color:|\\/span>)[^>]+>/gi, '')\n    \n    // Nettoyer les espaces multiples\n    .replace(/[ \\t]+/g, ' ')\n    .replace(/\\n[ \\t]+/g, '\\n')\n    \n    // Normaliser les sauts de ligne sans détruire la structure\n    .replace(/\\n{3,}/g, '\\n\\n') // Maximum 2 sauts consécutifs\n    \n    .trim();\n\n  return markdown;\n};\n\n/**\n * Convertit du Markdown en HTML\n * @param {string} markdown - Le contenu Markdown à convertir\n * @returns {string} - Le contenu HTML\n */\nexport const markdownToHtml = (markdown) => {\n  if (!markdown) return '';\n  \n  // Préserver les spans HTML existants dans le Markdown\n  const spanMarkers = [];\n  let tempMarkdown = markdown.replace(/<span[^>]*style=\"[^\"]*color:[^\"]*\"[^>]*>.*?<\\/span>/gis, (match) => {\n    const marker = `__SPAN_PRESERVE_${spanMarkers.length}__`;\n    spanMarkers.push(match);\n    return marker;\n  });\n  \n  let html = tempMarkdown\n    // Échapper les caractères HTML spéciaux SAUF pour les spans préservés\n    .replace(/&(?!__SPAN_PRESERVE_)/g, '&amp;')\n    .replace(/<(?!__SPAN_PRESERVE_)/g, '&lt;')\n    .replace(/>(?!__SPAN_PRESERVE_)/g, '&gt;')\n    \n    // Titres H1-H6\n    .replace(/^#{6}\\s+(.+)$/gm, '<h6>$1</h6>')\n    .replace(/^#{5}\\s+(.+)$/gm, '<h5>$1</h5>')\n    .replace(/^#{4}\\s+(.+)$/gm, '<h4>$1</h4>')\n    .replace(/^#{3}\\s+(.+)$/gm, '<h3>$1</h3>')\n    .replace(/^#{2}\\s+(.+)$/gm, '<h2>$1</h2>')\n    .replace(/^#{1}\\s+(.+)$/gm, '<h1>$1</h1>')\n    \n    // Images - traiter AVANT les autres conversions pour éviter les conflits\n    .replace(/!\\[([^\\]]*)\\]\\(([^)]+)\\)\\{([^}]+)\\}/g, (match, alt, src, dimensions) => {\n      let imgTag = `<img src=\"${src}\" alt=\"${alt}\"`;\n      \n      // Parser les dimensions width=X height=Y\n      const widthMatch = dimensions.match(/width=([\\w%]+)/);\n      const heightMatch = dimensions.match(/height=([\\w%]+)/);\n      \n      if (widthMatch) {\n        imgTag += ` width=\"${widthMatch[1]}\"`;\n      }\n      if (heightMatch) {\n        imgTag += ` height=\"${heightMatch[1]}\"`;\n      }\n      \n      imgTag += ' style=\"max-width: 100%; height: auto; margin: 0.5em 0;\" />';\n      return imgTag;\n    })\n    // Images sans dimensions (fallback)\n    .replace(/!\\[([^\\]]*)\\]\\(([^)]+)\\)/g, '<img src=\"$2\" alt=\"$1\" style=\"max-width: 100%; height: auto; margin: 0.5em 0;\" />')\n    \n    // Formatage gras et italique\n    .replace(/\\*\\*([^*]+)\\*\\*/g, '<strong>$1</strong>')\n    .replace(/\\*([^*]+)\\*/g, '<em>$1</em>')\n    \n    // TRAITER LES LISTES AVANT LA CONVERSION \\n -> <br>\n    \n    // Listes à puces\n    .replace(/^(\\s*)-\\s+(.+)$/gm, '<li data-type=\"bullet\">$2</li>')\n    \n    // Listes numérotées - préserver le numéro original\n    .replace(/^(\\s*)(\\d+)\\.\\s+(.+)$/gm, '<li data-type=\"number\" data-number=\"$2\">$3</li>')\n    \n    // Listes alphabétiques - préserver la lettre originale\n    .replace(/^(\\s*)([a-z])\\.\\s+(.+)$/gm, '<li data-type=\"letter\" data-letter=\"$2\">$3</li>')\n    \n    // Regrouper les éléments de liste consécutifs PAR TYPE HOMOGÈNE\n    .replace(/(<li[^>]*data-type=\"[^\"]*\"[^>]*>.*?<\\/li>\\n?)+/gs, (match) => {\n      const items = match.match(/<li[^>]*data-type=\"[^\"]*\"[^>]*>.*?<\\/li>/gs) || [];\n      const groups = [];\n      let currentGroup = [];\n      let currentType = null;\n      \n      // Séparer par type homogène\n      for (const item of items) {\n        const typeMatch = item.match(/data-type=\"([^\"]*)\"/); \n        const itemType = typeMatch ? typeMatch[1] : null;\n        \n        if (itemType !== currentType) {\n          // Nouveau type détecté - finaliser le groupe précédent\n          if (currentGroup.length > 0) {\n            groups.push({ type: currentType, items: currentGroup });\n          }\n          currentGroup = [item];\n          currentType = itemType;\n        } else {\n          // Même type - ajouter au groupe actuel\n          currentGroup.push(item);\n        }\n      }\n      \n      // Finaliser le dernier groupe\n      if (currentGroup.length > 0) {\n        groups.push({ type: currentType, items: currentGroup });\n      }\n      \n      // Convertir chaque groupe en HTML approprié\n      return groups.map(group => {\n        const { type, items } = group;\n        \n        if (type === 'letter') {\n          // Listes alphabétiques\n          const firstLetterMatch = items[0].match(/data-letter=\"([a-z])\"/); \n          const startLetter = firstLetterMatch ? firstLetterMatch[1] : 'a';\n          const startIndex = startLetter.charCodeAt(0) - 97; // a=0, b=1, c=2...\n          const cleanItems = items.map(item => item.replace(/ data-type=\"[^\"]*\"| data-letter=\"[^\"]*\"/g, ''));\n          \n          if (startIndex > 0) {\n            return `<ol style=\"list-style-type: lower-alpha;\" start=\"${startIndex + 1}\">${cleanItems.join('')}</ol>`;\n          } else {\n            return `<ol style=\"list-style-type: lower-alpha;\">${cleanItems.join('')}</ol>`;\n          }\n        } else if (type === 'number') {\n          // Listes numérotées\n          const firstNumberMatch = items[0].match(/data-number=\"(\\d+)\"/); \n          const startNumber = firstNumberMatch ? parseInt(firstNumberMatch[1]) : 1;\n          const cleanItems = items.map(item => item.replace(/ data-type=\"[^\"]*\"| data-number=\"[^\"]*\"/g, ''));\n          \n          if (startNumber > 1) {\n            return `<ol start=\"${startNumber}\">${cleanItems.join('')}</ol>`;\n          } else {\n            return `<ol>${cleanItems.join('')}</ol>`;\n          }\n        } else if (type === 'bullet') {\n          // Listes à puces\n          const cleanItems = items.map(item => item.replace(/ data-type=\"[^\"]*\"/g, ''));\n          return `<ul>${cleanItems.join('')}</ul>`;\n        } else {\n          // Type inconnu - retourner tel quel\n          return items.join('');\n        }\n      }).join('\\n') + '\\n';\n    })\n    \n    // Traiter les paragraphes par blocs séparés par double saut AVANT conversion \\n → <br>\n    .split('\\n\\n')\n    .map(block => {\n      block = block.trim();\n      if (!block) return '';\n      \n      // Si c'est déjà du HTML (titres, listes), le garder tel quel SANS conversion \\n → <br>\n      if (block.match(/^<h[1-6]|<ul|<ol/)) return block;\n      \n      // Si le bloc contient des listes, ne pas l'envelopper dans des divs\n      if (block.match(/<ul|<ol/)) return block;\n      \n      // Pour les autres blocs, convertir \\n → <br> puis traiter\n      const processedBlock = block.replace(/\\n(?!\\n)(?!$)/g, '<br>');\n      const lines = processedBlock.split('<br>').map(line => line.trim()).filter(line => line);\n      \n      if (lines.length === 1) {\n        // Une seule ligne → <div> (ligne simple)\n        return `<div>${lines[0]}</div>`;\n      } else {\n        // Plusieurs lignes → <div> avec <br> pour préserver les sauts\n        return `<div>${lines.join('<br>')}</div>`;\n      }\n    })\n    .filter(block => block)\n    .join('\\n')\n    \n    // Restaurer les spans colorés préservés\n    .replace(/__SPAN_PRESERVE_(\\d+)__/g, (match, index) => {\n      return spanMarkers[parseInt(index)] || '';\n    })\n    \n    // Nettoyer les <br> et espaces indésirables après les balises de bloc\n    .replace(/(<\\/(?:ul|ol|h[1-6])>)\\s*<br>/g, '$1')\n    .replace(/(<\\/(?:ul|ol|h[1-6])>)\\s*\\n/g, '$1')\n    \n    // Nettoyer les lignes vides multiples\n    .replace(/\\n{2,}/g, '\\n')\n    .replace(/^\\n+|\\n+$/g, '');\n\n  return html;\n};\n\n/**\n * Détecte si le contenu contient de la syntaxe Markdown\n * @param {string} content - Le contenu à analyser\n * @returns {boolean} - true si c'est du Markdown\n */\nexport const isMarkdownContent = (content) => {\n  if (!content) return false;\n  \n  const markdownPatterns = [\n    /^#{1,6}\\s+/m,           // Titres\n    /\\*\\*[^*]+\\*\\*/,         // Gras\n    /\\*[^*]+\\*/,             // Italique\n    /^[-*]\\s+/m,             // Listes à puces\n    /^\\d+\\.\\s+/m,            // Listes numérotées\n    /^[a-z]\\.\\s+/m,          // Listes alphabétiques\n    /!\\[.*?\\]\\([^)]+\\)/      // Images\n  ];\n  \n  return markdownPatterns.some(pattern => pattern.test(content));\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}