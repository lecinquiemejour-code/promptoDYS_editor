{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useCallback } from 'react';\nconst DB_NAME = 'EditorImageDB';\nconst DB_VERSION = 1;\nconst STORE_NAME = 'images';\nexport const useImageStorage = () => {\n  _s();\n  const [db, setDb] = useState(null);\n\n  // Ouvrir/cr√©er la base IndexedDB\n  const initDB = useCallback(async () => {\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open(DB_NAME, DB_VERSION);\n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => resolve(request.result);\n      request.onupgradeneeded = event => {\n        const database = event.target.result;\n\n        // Cr√©er le store si n√©cessaire\n        if (!database.objectStoreNames.contains(STORE_NAME)) {\n          const imageStore = database.createObjectStore(STORE_NAME, {\n            keyPath: 'id'\n          });\n          imageStore.createIndex('fileName', 'fileName', {\n            unique: false\n          });\n          imageStore.createIndex('timestamp', 'timestamp', {\n            unique: false\n          });\n        }\n      };\n    });\n  }, []);\n\n  // Stocker une image blob dans IndexedDB\n  const storeImage = useCallback(async (blobUrl, fileName = 'image') => {\n    try {\n      // Initialiser la DB si n√©cessaire\n      const database = db || (await initDB());\n      if (!db) setDb(database);\n\n      // R√©cup√©rer le blob depuis l'URL\n      const response = await fetch(blobUrl);\n      const blob = await response.blob();\n\n      // G√©n√©rer un ID unique\n      const imageId = `img_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n      // Pr√©parer les donn√©es √† stocker\n      const imageData = {\n        id: imageId,\n        fileName: fileName,\n        blob: blob,\n        mimeType: blob.type,\n        size: blob.size,\n        timestamp: new Date().toISOString()\n      };\n\n      // √âcrire dans IndexedDB\n      const transaction = database.transaction([STORE_NAME], 'readwrite');\n      const store = transaction.objectStore(STORE_NAME);\n      return new Promise((resolve, reject) => {\n        const request = store.add(imageData);\n        request.onsuccess = () => {\n          console.log('‚úÖ Image stock√©e dans IndexedDB:', fileName, imageId);\n          resolve(imageId);\n        };\n        request.onerror = () => reject(request.error);\n      });\n    } catch (error) {\n      console.error('‚ùå Erreur stockage image IndexedDB:', error);\n      throw error;\n    }\n  }, [db, initDB]);\n\n  // R√©cup√©rer une image depuis IndexedDB et cr√©er une blob URL\n  const loadImage = useCallback(async imageId => {\n    try {\n      // Initialiser la DB si n√©cessaire\n      const database = db || (await initDB());\n      if (!db) setDb(database);\n      const transaction = database.transaction([STORE_NAME], 'readonly');\n      const store = transaction.objectStore(STORE_NAME);\n      return new Promise((resolve, reject) => {\n        const request = store.get(imageId);\n        request.onsuccess = () => {\n          const result = request.result;\n          if (result) {\n            // Cr√©er une blob URL pour l'affichage\n            const blobUrl = URL.createObjectURL(result.blob);\n            console.log('‚úÖ Image charg√©e depuis IndexedDB:', result.fileName, imageId);\n            resolve({\n              blobUrl,\n              fileName: result.fileName,\n              mimeType: result.mimeType,\n              size: result.size\n            });\n          } else {\n            console.warn('‚ö†Ô∏è Image non trouv√©e dans IndexedDB:', imageId);\n            resolve(null);\n          }\n        };\n        request.onerror = () => reject(request.error);\n      });\n    } catch (error) {\n      console.error('‚ùå Erreur chargement image IndexedDB:', error);\n      return null;\n    }\n  }, [db, initDB]);\n\n  // Lister toutes les images stock√©es\n  const listImages = useCallback(async () => {\n    try {\n      const database = db || (await initDB());\n      if (!db) setDb(database);\n      const transaction = database.transaction([STORE_NAME], 'readonly');\n      const store = transaction.objectStore(STORE_NAME);\n      return new Promise((resolve, reject) => {\n        const request = store.getAll();\n        request.onsuccess = () => {\n          const images = request.result.map(img => ({\n            id: img.id,\n            fileName: img.fileName,\n            mimeType: img.mimeType,\n            size: img.size,\n            timestamp: img.timestamp\n          }));\n          resolve(images);\n        };\n        request.onerror = () => reject(request.error);\n      });\n    } catch (error) {\n      console.error('‚ùå Erreur listage images IndexedDB:', error);\n      return [];\n    }\n  }, [db, initDB]);\n\n  // Supprimer une image\n  const deleteImage = useCallback(async imageId => {\n    try {\n      const database = db || (await initDB());\n      if (!db) setDb(database);\n      const transaction = database.transaction([STORE_NAME], 'readwrite');\n      const store = transaction.objectStore(STORE_NAME);\n      return new Promise((resolve, reject) => {\n        const request = store.delete(imageId);\n        request.onsuccess = () => {\n          console.log('‚úÖ Image supprim√©e de IndexedDB:', imageId);\n          resolve(true);\n        };\n        request.onerror = () => reject(request.error);\n      });\n    } catch (error) {\n      console.error('‚ùå Erreur suppression image IndexedDB:', error);\n      return false;\n    }\n  }, [db, initDB]);\n\n  // Nettoyer les images orphelines (non r√©f√©renc√©es dans le contenu)\n  const cleanupOrphanImages = useCallback(async htmlContent => {\n    try {\n      const allImages = await listImages();\n      const usedImageIds = [];\n\n      // Extraire tous les IDs d'images r√©f√©renc√©es dans le HTML\n      const indexedImageRegex = /indexed:\\/\\/(img_[^\"'\\s]+)/g;\n      let match;\n      while ((match = indexedImageRegex.exec(htmlContent)) !== null) {\n        usedImageIds.push(match[1]);\n      }\n\n      // Supprimer les images non r√©f√©renc√©es\n      let deletedCount = 0;\n      for (const image of allImages) {\n        if (!usedImageIds.includes(image.id)) {\n          await deleteImage(image.id);\n          deletedCount++;\n        }\n      }\n      if (deletedCount > 0) {\n        console.log(`üßπ ${deletedCount} image(s) orpheline(s) supprim√©e(s)`);\n      }\n      return deletedCount;\n    } catch (error) {\n      console.error('‚ùå Erreur nettoyage images IndexedDB:', error);\n      return 0;\n    }\n  }, [listImages, deleteImage]);\n  return {\n    storeImage,\n    loadImage,\n    listImages,\n    deleteImage,\n    cleanupOrphanImages\n  };\n};\n_s(useImageStorage, \"C4IfwUtTHYQg7OO4JLAdgq3BNNs=\");","map":{"version":3,"names":["useState","useCallback","DB_NAME","DB_VERSION","STORE_NAME","useImageStorage","_s","db","setDb","initDB","Promise","resolve","reject","request","indexedDB","open","onerror","error","onsuccess","result","onupgradeneeded","event","database","target","objectStoreNames","contains","imageStore","createObjectStore","keyPath","createIndex","unique","storeImage","blobUrl","fileName","response","fetch","blob","imageId","Date","now","Math","random","toString","substr","imageData","id","mimeType","type","size","timestamp","toISOString","transaction","store","objectStore","add","console","log","loadImage","get","URL","createObjectURL","warn","listImages","getAll","images","map","img","deleteImage","delete","cleanupOrphanImages","htmlContent","allImages","usedImageIds","indexedImageRegex","match","exec","push","deletedCount","image","includes"],"sources":["C:/Users/JEAN-NOELLEFEBVRE-SA/CascadeProjects/editor/src/hooks/useImageStorage.js"],"sourcesContent":["import { useState, useCallback } from 'react';\n\nconst DB_NAME = 'EditorImageDB';\nconst DB_VERSION = 1;\nconst STORE_NAME = 'images';\n\nexport const useImageStorage = () => {\n  const [db, setDb] = useState(null);\n\n  // Ouvrir/cr√©er la base IndexedDB\n  const initDB = useCallback(async () => {\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open(DB_NAME, DB_VERSION);\n      \n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => resolve(request.result);\n      \n      request.onupgradeneeded = (event) => {\n        const database = event.target.result;\n        \n        // Cr√©er le store si n√©cessaire\n        if (!database.objectStoreNames.contains(STORE_NAME)) {\n          const imageStore = database.createObjectStore(STORE_NAME, { keyPath: 'id' });\n          imageStore.createIndex('fileName', 'fileName', { unique: false });\n          imageStore.createIndex('timestamp', 'timestamp', { unique: false });\n        }\n      };\n    });\n  }, []);\n\n  // Stocker une image blob dans IndexedDB\n  const storeImage = useCallback(async (blobUrl, fileName = 'image') => {\n    try {\n      // Initialiser la DB si n√©cessaire\n      const database = db || await initDB();\n      if (!db) setDb(database);\n\n      // R√©cup√©rer le blob depuis l'URL\n      const response = await fetch(blobUrl);\n      const blob = await response.blob();\n\n      // G√©n√©rer un ID unique\n      const imageId = `img_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n      \n      // Pr√©parer les donn√©es √† stocker\n      const imageData = {\n        id: imageId,\n        fileName: fileName,\n        blob: blob,\n        mimeType: blob.type,\n        size: blob.size,\n        timestamp: new Date().toISOString()\n      };\n\n      // √âcrire dans IndexedDB\n      const transaction = database.transaction([STORE_NAME], 'readwrite');\n      const store = transaction.objectStore(STORE_NAME);\n      \n      return new Promise((resolve, reject) => {\n        const request = store.add(imageData);\n        request.onsuccess = () => {\n          console.log('‚úÖ Image stock√©e dans IndexedDB:', fileName, imageId);\n          resolve(imageId);\n        };\n        request.onerror = () => reject(request.error);\n      });\n\n    } catch (error) {\n      console.error('‚ùå Erreur stockage image IndexedDB:', error);\n      throw error;\n    }\n  }, [db, initDB]);\n\n  // R√©cup√©rer une image depuis IndexedDB et cr√©er une blob URL\n  const loadImage = useCallback(async (imageId) => {\n    try {\n      // Initialiser la DB si n√©cessaire\n      const database = db || await initDB();\n      if (!db) setDb(database);\n\n      const transaction = database.transaction([STORE_NAME], 'readonly');\n      const store = transaction.objectStore(STORE_NAME);\n      \n      return new Promise((resolve, reject) => {\n        const request = store.get(imageId);\n        \n        request.onsuccess = () => {\n          const result = request.result;\n          if (result) {\n            // Cr√©er une blob URL pour l'affichage\n            const blobUrl = URL.createObjectURL(result.blob);\n            console.log('‚úÖ Image charg√©e depuis IndexedDB:', result.fileName, imageId);\n            resolve({\n              blobUrl,\n              fileName: result.fileName,\n              mimeType: result.mimeType,\n              size: result.size\n            });\n          } else {\n            console.warn('‚ö†Ô∏è Image non trouv√©e dans IndexedDB:', imageId);\n            resolve(null);\n          }\n        };\n        \n        request.onerror = () => reject(request.error);\n      });\n\n    } catch (error) {\n      console.error('‚ùå Erreur chargement image IndexedDB:', error);\n      return null;\n    }\n  }, [db, initDB]);\n\n  // Lister toutes les images stock√©es\n  const listImages = useCallback(async () => {\n    try {\n      const database = db || await initDB();\n      if (!db) setDb(database);\n\n      const transaction = database.transaction([STORE_NAME], 'readonly');\n      const store = transaction.objectStore(STORE_NAME);\n      \n      return new Promise((resolve, reject) => {\n        const request = store.getAll();\n        request.onsuccess = () => {\n          const images = request.result.map(img => ({\n            id: img.id,\n            fileName: img.fileName,\n            mimeType: img.mimeType,\n            size: img.size,\n            timestamp: img.timestamp\n          }));\n          resolve(images);\n        };\n        request.onerror = () => reject(request.error);\n      });\n\n    } catch (error) {\n      console.error('‚ùå Erreur listage images IndexedDB:', error);\n      return [];\n    }\n  }, [db, initDB]);\n\n  // Supprimer une image\n  const deleteImage = useCallback(async (imageId) => {\n    try {\n      const database = db || await initDB();\n      if (!db) setDb(database);\n\n      const transaction = database.transaction([STORE_NAME], 'readwrite');\n      const store = transaction.objectStore(STORE_NAME);\n      \n      return new Promise((resolve, reject) => {\n        const request = store.delete(imageId);\n        request.onsuccess = () => {\n          console.log('‚úÖ Image supprim√©e de IndexedDB:', imageId);\n          resolve(true);\n        };\n        request.onerror = () => reject(request.error);\n      });\n\n    } catch (error) {\n      console.error('‚ùå Erreur suppression image IndexedDB:', error);\n      return false;\n    }\n  }, [db, initDB]);\n\n  // Nettoyer les images orphelines (non r√©f√©renc√©es dans le contenu)\n  const cleanupOrphanImages = useCallback(async (htmlContent) => {\n    try {\n      const allImages = await listImages();\n      const usedImageIds = [];\n      \n      // Extraire tous les IDs d'images r√©f√©renc√©es dans le HTML\n      const indexedImageRegex = /indexed:\\/\\/(img_[^\"'\\s]+)/g;\n      let match;\n      while ((match = indexedImageRegex.exec(htmlContent)) !== null) {\n        usedImageIds.push(match[1]);\n      }\n\n      // Supprimer les images non r√©f√©renc√©es\n      let deletedCount = 0;\n      for (const image of allImages) {\n        if (!usedImageIds.includes(image.id)) {\n          await deleteImage(image.id);\n          deletedCount++;\n        }\n      }\n\n      if (deletedCount > 0) {\n        console.log(`üßπ ${deletedCount} image(s) orpheline(s) supprim√©e(s)`);\n      }\n\n      return deletedCount;\n\n    } catch (error) {\n      console.error('‚ùå Erreur nettoyage images IndexedDB:', error);\n      return 0;\n    }\n  }, [listImages, deleteImage]);\n\n  return {\n    storeImage,\n    loadImage,\n    listImages,\n    deleteImage,\n    cleanupOrphanImages\n  };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}